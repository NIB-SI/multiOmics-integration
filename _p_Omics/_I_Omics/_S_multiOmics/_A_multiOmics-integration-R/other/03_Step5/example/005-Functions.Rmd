```{r echo=FALSE}
###############################################
##                                           ##
## (c) Andrej Blejec (andrej.blejec@nib.si)  ##
##                                           ##
###############################################
```
```{r echo=FALSE,results='hide'}
options(width=70)
```

## Additional functions

```{r}
# cat + end of line
catln <- function(...) cat(...,"\n")
```


### Panel functions

Panel functions for function `pairs()`
```{r }
panel.cor <- function(x, y, digits = 2, prefix = "",
cex.cor) {
usr <- par("usr")
on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- (cor(x, y, use = "pairwise.complete.obs"))
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste(prefix, txt, sep = "")
if (missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * abs(r))
}
panel.abline <- function(x, y, col.ab = "red", lwd.ab,...) {
points(x, y,...)
if (missing(lwd.ab))
lwd.ab <- 1
abline(lm(y ~ x), col = col.ab, lwd = lwd.ab, ...)
}
# Call:  pairs(X, lower.panel = panel.cor, cex.cor = 5, upper.panel = panel.abline)
```
### `plt.var()`
Adapted function `plt.var()`. For `X`, correlation between `X` and scores of `X` is plotted (namely coefficients of `X`). I assume that it should also be for `Y` instead of correlation between `Y` and scores of `X`.
```{r }
my.plt.var <- function (res, d1, d2, int = 0.5, var.label = FALSE, Xnames = NULL,
    Ynames = NULL, cex=3)
{
    if (!var.label) {
        plot(0, type = "n", xlim = c(-1, 1), ylim = c(-1,
            1), xlab = paste("Dimension ", d1), ylab = paste("Dimension ",
            d2))
        points(res$scores$corr.X.xscores[, d1], res$scores$corr.X.xscores[,
            d2], pch = 20, cex = 1.2, col = "red")
        points(res$scores$corr.Y.yscores[, d1], res$scores$corr.Y.yscores[,
            d2], pch = 24, cex = 0.7, col = "blue")
    }
    else {
        if (is.null(Xnames))
            Xnames = res$names$Xnames
        if (is.null(Ynames))
            Ynames = res$names$Ynames
        plot(0, type = "n", xlim = c(-1, 1), ylim = c(-1,
            1), xlab = paste("Dimension ", d1), ylab = paste("Dimension ",
            d2))
        text(res$scores$corr.X.xscores[, d1], res$scores$corr.X.xscores[,
            d2], Xnames, col = "red", font = 2,cex=cex)
        text(res$scores$corr.Y.yscores[, d1], res$scores$corr.Y.yscores[,
            d2], Ynames, col = "blue", font = 3,cex=cex)
    }
    abline(v = 0, h = 0)
    lines(cos(seq(0, 2 * pi, l = 100)), sin(seq(0, 2 * pi, l = 100)))
    lines(int * cos(seq(0, 2 * pi, l = 100)), int * sin(seq(0,
        2 * pi, l = 100)))
}

```

```{r echo=FALSE}
 my.plotVar <-
function (object, comp = NULL, comp.select = comp, plot = TRUE,
    var.names = NULL, blocks = NULL, X.label = NULL, Y.label = NULL,
    Z.label = NULL, abline = TRUE, col, cex, pch, font, cutoff = 0,
    rad.in = 0.5, title = "Correlation Circle Plots", legend = FALSE,
    legend.title = "Block", style = "ggplot2", overlap = TRUE,
    axes.box = "all", label.axes.box = "both")
{
    class.object = class(object)
    object.pls = c("mixo_pls", "mixo_spls", "mixo_mlspls",
        "mixo_mlsplsda", "rcc")
    object.pca = c("ipca", "sipca", "pca",
        "spca")
    object.blocks = c("sgcca", "rgcca")
    arg.call = match.call()
    user.arg = names(arg.call)[-1]
    err = tryCatch(mget(names(formals()), sys.frame(sys.nframe())),
        error = function(e) e)
    if ("simpleError" %in% class(err))
        stop(err[[1]], ".", call. = FALSE)
    if (!style %in% c("ggplot2", "lattice", "graphics",
        "3d"))
        stop("'style' must be one of 'ggplot2', '3d' , lattice' or 'graphics'.",
            call. = FALSE)
    if (length(plot) > 1)
        stop("'plot' must be single logical value.", call. = FALSE)
    else if (!is.logical(plot))
        stop("'plot' must be logical.", call. = FALSE)
    if (!plot) {
        style = "N"
    }
    if (style == "3d") {
        choices = c("axes", "box", "bbox",
            "all")
        axes.box = choices[pmatch(axes.box, choices)]
        if (is.na(axes.box))
            stop("'axes.box' should be a subset of {'axes', 'box', 'bbox', 'all'}.",
                call. = FALSE)
        choices = c("axes", "box", "both")
        label.axes.box = choices[pmatch(label.axes.box, choices)]
        if (is.na(label.axes.box))
            stop("'label.axes.box' should be one of 'axes', 'box' or 'both'.",
                call. = FALSE)
    }
    ncomp = object$ncomp
    if (any(class.object %in% object.blocks)) {
        if (length(legend) != 1 || !is.logical(legend))
            stop("'legend' must be a logical value.", call. = FALSE)
        if (is.null(blocks)) {
            blocks = names(object$X)
            if (any(class.object == "DA"))
                blocks = names(object$X)
        }
        else if (is.numeric(blocks) & min(blocks) > 0 & max(blocks) <=
            length(object$names$blocks)) {
            blocks = object$names$blocks[blocks]
        }
        else if (is.character(blocks)) {
            if (!any(blocks %in% object$names$blocks))
                stop("One element of 'blocks' does not match with the names of the blocks")
        }
        else {
            stop("Incorrect value for 'blocks'", call. = FALSE)
        }
        object$variates = object$variates[names(object$variates) %in%
            blocks]
        object$names$colnames = object$names$colnames[names(object$names$colnames) %in%
            blocks]
        object$blocks = object$X[names(object$X) %in% blocks]
        if (any(object$ncomp[blocks] == 1)) {
            stop(paste("The number of components for one selected block '",
                paste(blocks, collapse = " - "), "' is 1. The number of components must be superior or equal to 2."),
                call. = FALSE)
        }
        ncomp = object$ncomp[blocks]
    }
    else if (any(class.object %in% c("rcc", "mixo_pls",
        "mixo_spls", "mixo_mlspls")) & all(class.object !=
        "DA")) {
        if (!(length(legend) == 1 & is.logical(legend) || (length(legend) ==
            2)))
            stop("'legend' must be a logical value or a vector of 2 names for X and Y.",
                call. = FALSE)
        if (length(legend) == 2) {
            blocks = legend
            legend = TRUE
        }
        else {
            blocks = c("X", "Y")
        }
    }
    else {
        if (length(legend) != 1)
            stop("'legend' must be a logical value or a vector of 1 name for X.",
                call. = FALSE)
        if (is.logical(legend)) {
            blocks = "X"
        }
        else {
            blocks = legend
            legend = TRUE
        }
    }
    if (length(legend.title) > 1)
        stop("'legend.title' needs to be a single value (length 1)")
    if (!is.numeric(rad.in) | (rad.in > 1) | (rad.in < 0))
        stop("The value taken by 'rad.in' must be between 0 and 1",
            call. = FALSE)
    if (!is.numeric(cutoff) | (cutoff > 1) | (cutoff < 0))
        stop("The value taken by 'cutoff' must be between 0 and 1",
            call. = FALSE)
    if (is.null(comp)) {
        if (style == "3d") {
            comp = seq_len(3)
        }
        else {
            comp = seq_len(2)
        }
    }
    if (length(comp) != 2 && !(style == "3d")) {
        stop("'comp' must be a numeric vector of length 2.",
            call. = FALSE)
    }
    else if (length(comp) != 3 && (style == "3d")) {
        stop("'comp' must be a numeric vector of length 3.",
            call. = FALSE)
    }
    if (!is.numeric(comp))
        stop("Invalid vector for 'comp'.")
    if (any(ncomp < max(comp)) || min(comp) <= 0)
        stop("Each element of 'comp' must be positive smaller or equal than ",
            min(object$ncomp), ".", call. = FALSE)
    comp1 = round(comp[1])
    comp2 = round(comp[2])
    if (style == "3d")
        comp3 = round(comp[3])
    if (!is.null(comp.select)) {
        if (!is.numeric(comp.select))
            stop("Invalid vector for 'comp'.", call. = FALSE)
        if (any(ncomp < max(comp.select)) || min(comp.select) <=
            0)
            stop("Each element of 'comp.select' must be positive and smaller or equal than ",
                max(object$ncomp), ".", call. = FALSE)
    }
    else {
        comp.select = comp
    }
    if (length(abline) > 1) {
        stop("'abline' must be single logical value.",
            call. = FALSE)
    }
    else if (!is.logical(abline)) {
        stop("'abline' must be logical.", call. = FALSE)
    }
    cord.X = sample.X = ind.var.sel = list()
    if (style == "3d") {
        if (any(class.object %in% c(object.pls, object.blocks))) {
            if (any(class.object == "rcc")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2, comp3)] + object$variates$Y[,
                  c(comp1, comp2, comp3)], use = "pairwise")
                cord.X[[2]] = cor(object$Y, object$variates$X[,
                  c(comp1, comp2, comp3)] + object$variates$Y[,
                  c(comp1, comp2, comp3)], use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% "mixo_plsda")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2, comp3)], use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% "mixo_pls")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2, comp3)], use = "pairwise")
                cord.X[[2]] = cor(object$Y, if (object$mode ==
                  "canonical") {
                  object$variates$Y[, c(comp1, comp2, comp3)]
                }
                else {
                  object$variates$X[, c(comp1, comp2, comp3)]
                }, use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% c("mixo_splsda",
                "mixo_mlsplsda"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(unique(c(comp1, comp2,
                    comp3, comp.select)), function(x) {
                    selectVar(object, comp = x)$name
                  })))], object$variates$X[, c(comp1, comp2,
                  comp3, comp.select)], use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
                if (!is.null(comp.select)) {
                  cord.X[[1]] = cord.X[[1]][row.names(cord.X[[1]]) %in%
                    unique(unlist(lapply(comp.select, function(x) {
                      selectVar(object, comp = x)$name
                    }))), , drop = FALSE]
                }
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
            }
            else if (any(class.object %in% c("mixo_spls",
                "mixo_mlspls"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(c(comp1, comp2, comp3),
                    function(x) {
                      selectVar(object, comp = x)$X$name
                    })))], object$variates$X[, c(comp1, comp2,
                  comp3)], use = "pairwise")
                cord.X[[2]] = cor(object$Y[, colnames(object$Y) %in%
                  unique(unlist(lapply(c(comp1, comp2, comp3),
                    function(x) {
                      selectVar(object, comp = x)$Y$name
                    })))], if (object$mode == "canonical") {
                  object$variates$Y[, c(comp1, comp2, comp3)]
                }
                else {
                  object$variates$X[, c(comp1, comp2, comp3)]
                }, use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
                ind.var.sel[[2]] = sample.X[[2]] = seq_len(length(colnames(object$Y)))
                if (!is.null(comp.select)) {
                  cord.X[[1]] = cord.X[[1]][row.names(cord.X[[1]]) %in%
                    unique(unlist(lapply(comp.select, function(x) {
                      selectVar(object, comp = x)$X$name
                    }))), , drop = FALSE]
                  cord.X[[2]] = cord.X[[2]][row.names(cord.X[[2]]) %in%
                    unique(unlist(lapply(comp.select, function(x) {
                      selectVar(object, comp = x)$Y$name
                    }))), , drop = FALSE]
                }
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
                ind.var.sel[[2]] = which(colnames(object$Y) %in%
                  rownames(cord.X[[2]]))
            }
            else {
                cord.X = lapply(blocks, function(x) {
                  cor(object$blocks[[x]], object$variates[[x]][,
                    c(comp1, comp2, comp3)], use = "pairwise")
                })
                ind.var.sel = sample.X = lapply(object$blocks,
                  function(x) {
                    seq_len(ncol(x))
                  })
                if (!is.null(comp.select)) {
                  cord.X = lapply(seq_len(length(cord.X)), function(z) {
                    cord.X[[z]][row.names(cord.X[[z]]) %in% unique(unlist(lapply(comp.select,
                      function(x) {
                        selectVar(object, block = z, comp = x)[[1]]$name
                      }))), , drop = FALSE]
                  })
                }
                for (i in seq_len(length(cord.X))) {
                  ind.var.sel[[i]] = which(colnames(object$X) %in%
                    rownames(cord.X[[i]]))
                }
            }
        }
        else if (any(class.object %in% object.pca)) {
            if (any(class.object %in% c("sipca", "spca"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(c(comp1, comp2, comp3),
                    function(x) {
                      selectVar(object, comp = x)$name
                    })))], object$x[, c(comp1, comp2, comp3)],
                  use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
                if (!is.null(comp.select)) {
                  cord.X[[1]] = cord.X[[1]][row.names(cord.X[[1]]) %in%
                    unique(unlist(lapply(comp.select, function(x) {
                      selectVar(object, comp = x)$name
                    }))), , drop = FALSE]
                }
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
            }
            else {
                cord.X[[1]] = cor(object$X, object$x[, c(comp1,
                  comp2, comp3)], use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
            }
        }
    }
    else {
        if (any(class.object %in% c(object.pls, object.blocks))) {
            if (any(class.object == "rcc")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2)] + object$variates$Y[, c(comp1,
                  comp2)], use = "pairwise")
                cord.X[[2]] = cor(object$Y, object$variates$X[,
                  c(comp1, comp2)] + object$variates$Y[, c(comp1,
                  comp2)], use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% "mixo_plsda")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2)], use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% "mixo_pls")) {
                cord.X[[1]] = cor(object$X, object$variates$X[,
                  c(comp1, comp2)], use = "pairwise")
                cord.X[[2]] = cor(object$Y, if (object$mode ==
                  "canonical") {
                  object$variates$Y[, c(comp1, comp2)]
                }
                else {
                  object$variates$X[, c(comp1, comp2)]
                }, use = "pairwise")
                sample.X = lapply(cord.X, function(x) {
                  seq_len(nrow(x))
                })
            }
            else if (any(class.object %in% c("mixo_splsda",
                "mixo_mlsplsda"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(comp.select, function(x) {
                    selectVar(object, comp = x)$name
                  }))), drop = FALSE], object$variates$X[, unique(c(comp1,
                  comp2))], use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
            }
            else if (any(class.object %in% c("mixo_spls",
                "mixo_mlspls"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(comp.select, function(x) {
                    selectVar(object, comp = x)$X$name
                  }))), drop = FALSE], object$variates$X[, c(comp1,
                  comp2)], use = "pairwise")
                cord.X[[2]] = cor(object$Y[, colnames(object$Y) %in%
                  unique(unlist(lapply(comp.select, function(x) {
                    selectVar(object, comp = x)$Y$name
                  }))), drop = FALSE], if (object$mode == "canonical") {
                  object$variates$Y[, c(comp1, comp2)]
                }
                else {
                  object$variates$X[, c(comp1, comp2)]
                }, use = "pairwise")
                sample.X[[1]] = seq_len(length(colnames(object$X)))
                sample.X[[2]] = seq_len(length(colnames(object$Y)))
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
                ind.var.sel[[2]] = which(colnames(object$Y) %in%
                  rownames(cord.X[[2]]))
            }
            else {
                cord.X = lapply(blocks, function(x) {
                  cor(object$blocks[[x]], object$variates[[x]][,
                    c(comp1, comp2)], use = "pairwise")
                })
                ind.var.sel = sample.X = lapply(object$blocks,
                  function(x) {
                    seq_len(ncol(x))
                  })
                if (!is.null(comp.select)) {
                  cord.X = lapply(seq_len(length(cord.X)), function(z) {
                    cord.X[[z]][row.names(cord.X[[z]]) %in% unique(unlist(lapply(comp.select,
                      function(x) {
                        selectVar(object, block = blocks[z],
                          comp = x)[[1]]$name
                      }))), , drop = FALSE]
                  })
                }
                for (i in seq_len(length(cord.X))) {
                  ind.var.sel[[i]] = which(colnames(object$blocks[[i]]) %in%
                    rownames(cord.X[[i]]))
                }
            }
        }
        else if (any(class.object %in% object.pca)) {
            if (any(class.object %in% c("sipca", "spca"))) {
                cord.X[[1]] = cor(object$X[, colnames(object$X) %in%
                  unique(unlist(lapply(comp.select, function(x) {
                    selectVar(object, comp = x)$name
                  }))), drop = FALSE], object$x[, c(comp1, comp2)],
                  use = "pairwise")
                sample.X[[1]] = seq_len(length(colnames(object$X)))
                ind.var.sel[[1]] = which(colnames(object$X) %in%
                  rownames(cord.X[[1]]))
            }
            else {
                cord.X[[1]] = cor(object$X, object$x[, c(comp1,
                  comp2)], use = "pairwise")
                ind.var.sel[[1]] = sample.X[[1]] = seq_len(length(colnames(object$X)))
            }
        }
    }
    if (any(class.object %in% object.blocks)) {
        VarX = lapply(seq_len(2), function(j) {
            do.call(cbind, lapply(object$variates, function(i) i[,
                comp[j]]))
        })
        corX = lapply(VarX, cor)
        if (any(sapply(corX, function(j) {
            any(j < 0)
        })))
            warning("We detected negative correlation between the variates of some blocks, which means that some clusters of variables observed on the correlation circle plot are not necessarily positively correlated.")
    }
    if (any(sapply(cord.X, nrow) == 0))
        stop("No variable selected on at least one block")
    if (is.null(X.label))
        X.label = paste("Component ", comp1)
    if (is.null(Y.label))
        Y.label = paste("Component ", comp2)
    if (is.null(Z.label) && style == "3d")
        Z.label = paste("Component ", comp3)
    if (!is.character(X.label))
        stop("'X.label' must be a character.", call. = FALSE)
    if (!is.character(Y.label))
        stop("'Y.label' must be a character.", call. = FALSE)
    missing.pch = FALSE
    if (missing(pch)) {
        missing.pch = TRUE
        if (style == "3d") {
            pch = unlist(lapply(seq_len(length(cord.X)), function(x) {
                rep(c("sphere", "tetra", "cube",
                  "octa", "icosa", "dodeca")[x],
                  sum(sapply(cord.X[x], nrow)))
            }))
        }
        else {
            pch = unlist(lapply(seq_len(length(cord.X)), function(x) {
                rep(seq_len(20)[x], sum(sapply(cord.X[x], nrow)))
            }))
        }
    }
    else if (((is.vector(pch, mode = "double") || is.vector(pch,
        mode = "integer")) && !(style == "3d")) ||
        (is.vector(pch, mode = "character") && style ==
            "3d")) {
        if (length(pch) != length(sample.X))
            stop.message("pch", sample.X)
        pch = unlist(lapply(seq_len(length(cord.X)), function(x) {
            rep(pch[x], sum(sapply(cord.X[x], nrow)))
        }))
    }
    else if (is.list(pch)) {
        if (length(pch) != length(sample.X) || length(unlist(pch)) !=
            sum(sapply(sample.X, length)))
            stop.message("pch", sample.X)
        if (length(ind.var.sel) != 0)
            pch = lapply(seq_len(length(pch)), function(x) {
                pch[[x]][ind.var.sel[[x]]]
            })
        pch = unlist(pch)
    }
    else if (style == "3d") {
        if (!all(pch %in% c("sphere", "tetra", "cube",
            "octa", "icosa", "dodeca")) &&
            style == "3d")
            stop("pch' must be a simple character or character vector from {'sphere', 'tetra', 'cube', 'octa', 'icosa', 'dodeca'}.",
                call. = FALSE)
    }
    else {
        stop.message("pch", sample.X)
    }
    if (missing(col)) {
        if (length(cord.X) < 10) {
            col = unlist(lapply(seq_len(length(cord.X)), function(x) {
                rep(color.mixo(x), sum(sapply(cord.X[x], nrow)))
            }))
        }
        else {
            col = unlist(lapply(seq_len(length(cord.X)), function(x) {
                rep(color.jet(length(cord.X))[x], sum(sapply(cord.X[x],
                  nrow)))
            }))
        }
    }
    else if (is.vector(col, mode = "double") | is.vector(col,
        mode = "character")) {
        if (length(col) != length(sample.X))
            stop.message("col", sample.X)
        col = unlist(lapply(seq_len(length(cord.X)), function(x) {
            rep(col[x], sum(sapply(cord.X[x], nrow)))
        }))
    }
    else if (is.list(col)) {
        if (length(col) != length(sample.X) || length(unlist(col)) !=
            sum(sapply(sample.X, length)))
            stop.message("col", sample.X)
        if (length(ind.var.sel) != 0)
            col = lapply(seq_len(length(col)), function(x) {
                col[[x]][ind.var.sel[[x]]]
            })
        col = unlist(col)
    }
    else {
        stop.message("col", sample.X)
    }
    if (missing(cex)) {
        if (style == "ggplot2") {
            cex = rep(5, sum(sapply(cord.X, nrow)))
        }
        else {
            cex = rep(1, sum(sapply(cord.X, nrow)))
        }
    }
    else if (is.vector(cex, mode = "double")) {
        if (length(cex) != length(cord.X))
            stop.message("cex", sample.X)
        cex = unlist(lapply(seq_len(length(cord.X)), function(x) {
            rep(cex[x], sum(sapply(cord.X[x], nrow)))
        }))
    }
    else if (is.list(cex)) {
        if (length(cex) != length(sample.X) || length(unlist(cex)) !=
            sum(sapply(sample.X, length)))
            stop.message("cex", sample.X)
        if (length(ind.var.sel) != 0)
            cex = lapply(seq_len(length(cex)), function(x) {
                cex[[x]][ind.var.sel[[x]]]
            })
        cex = unlist(cex)
    }
    else {
        stop.message("cex", sample.X)
    }
    if (missing(font)) {
        font = rep(1, sum(sapply(cord.X, nrow)))
    }
    else if (is.vector(font, mode = "numeric")) {
        if (length(font) != length(cord.X))
            stop.message("font", sample.X)
        font = unlist(lapply(seq_len(length(cord.X)), function(x) {
            rep(font[x], sum(sapply(cord.X[x], nrow)))
        }))
    }
    else if (is.list(font)) {
        if (length(font) != length(sample.X) || length(unlist(font)) !=
            sum(sapply(sample.X, length)))
            stop.message("font", sample.X)
        if (length(ind.var.sel) != 0)
            font = lapply(seq_len(length(font)), function(x) {
                font[[x]][ind.var.sel[[x]]]
            })
        font = unlist(font)
    }
    else {
        stop.message("font", sample.X)
    }
    ind.group = cumsum(c(0, sapply(cord.X, nrow)))
    if (is.null(var.names)) {
        var.names.list = unlist(sapply(cord.X, rownames))
        if (!missing.pch) {
            var.names = rep(FALSE, length(cord.X))
        }
        else {
            var.names = rep(TRUE, length(cord.X))
        }
    }
    else if (is.vector(var.names, mode = "logical")) {
        if (length(var.names) == 1) {
            var.names = rep(var.names, length(cord.X))
        }
        else if (length(var.names) != length(cord.X))
            stop.message("var.names", sample.X)
        var.names.list = unlist(lapply(seq_len(length(var.names)),
            function(x) {
                if (var.names[x]) {
                  rownames(cord.X[[x]])
                }
                else {
                  pch[(ind.group[x] + 1):ind.group[x + 1]]
                }
            }))
    }
    else if (is.list(var.names)) {
        if (length(var.names) != length(cord.X))
            stop.message("var.names", sample.X)
        length.var.names <- sum(sapply(seq_len(length(var.names)),
            function(x) {
                if (!lapply(var.names, is.logical)[[x]]) {
                  if (length(ind.var.sel) == 0) {
                    length(var.names[[x]])
                  } else {
                    length(var.names[[x]][ind.var.sel[[x]]])
                  }
                } else {
                  0
                }
            }))
        length.cord.X.names <- sum(sapply(seq_len(length(var.names)),
            function(x) {
                if (!lapply(var.names, is.logical)[[x]]) {
                  nrow(cord.X[[x]])
                } else {
                  0
                }
            }))
        if (length.var.names != length.cord.X.names) {
            stop.message("var.names", sample.X)
        }
        var.names.list = unlist(sapply(seq_len(length(var.names)),
            function(x) {
                if (lapply(var.names, is.logical)[[x]]) {
                  if (var.names[[x]]) {
                    row.names(cord.X[[x]])
                  }
                  else {
                    pch[(ind.group[x] + 1):ind.group[x + 1]]
                  }
                }
                else {
                  if (length(ind.var.sel) == 0) {
                    as.character(var.names[[x]])
                  }
                  else {
                    as.character(var.names[[x]])[ind.var.sel[[x]]]
                  }
                }
            }))
        var.names = sapply(var.names, function(x) {
            if (is.logical(x)) {
                x
            }
            else {
                TRUE
            }
        })
    }
    else {
        stop.message("var.names", sample.X)
    }
    circle = list()
    circle[[1]] = ellipse(0, levels = 1, t = 1)
    circle[[2]] = ellipse(0, levels = 1, t = rad.in)
    circle = data.frame(do.call("rbind", circle), Circle = c(rep("Main circle",
        100), rep("Inner circle", 100)))
    df = data.frame(do.call(rbind, cord.X), Block = paste0("Block: ",
        unlist(lapply(seq_len(length(cord.X)), function(z) {
            rep(blocks[z], nrow(cord.X[[z]]))
        }))))
    if (style == "3d")
        names(df)[seq_len(3)] = c("x", "y", "z")
    else names(df)[seq_len(2)] = c("x", "y")
    df$names = as.vector(var.names.list)
    df$pch = pch
    df$cex = cex
    df$col = col
    df$font = font
    if (missing.pch)
        df$pch = 1
    if (overlap) {
        df$Overlap = title
        df$Block = factor(unlist(lapply(seq_len(length(cord.X)),
            function(z) {
                rep(blocks[z], nrow(cord.X[[z]]))
            })))
        if (style %in% c("ggplot2", "lattice"))
            title = NULL
    }
    else {
        df$Overlap = df$Block
        if (style %in% c("ggplot2", "lattice"))
            df$Block = factor(unlist(lapply(seq_len(length(cord.X)),
                function(z) {
                  rep(blocks[z], nrow(cord.X[[z]]))
                })))
    }
    if (cutoff != 0) {
        if (style == "3d")
            df = df[abs(df$x) > cutoff | abs(df$y) > cutoff |
                abs(df$z) > cutoff, , drop = FALSE]
        else df = df[abs(df$x) > cutoff | abs(df$y) > cutoff,
            , drop = FALSE]
        ind.group = c(0, cumsum(table(df$Block)[unique(df$Block)]))
    }
    if (nrow(df) == 0)
        stop("Cutoff value very high for the components ",
            comp1, " and ", comp2, ".No variable was selected.")
    if (style == "ggplot2" & plot) {
        Block = NULL
        x = y = Circle = NULL
        p = ggplot(df, aes(x = x, y = y, color = Block)) + labs(title = title,
            x = X.label, y = Y.label) + theme_bw()
        for (i in levels(df$Block)) p = p + geom_point(data = subset(df,
            df$Block == i), size = 0, shape = 0)
        for (i in seq_len(length(var.names))) {
            if (var.names[i]) {
                p = p + geom_text(data = df[c((ind.group[i] +
                  1):ind.group[i + 1]), ], label = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "names"], size = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "cex"], color = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "col"], fontface = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "font"])
            }
            else {
                p = p + geom_point(data = df[c((ind.group[i] +
                  1):ind.group[i + 1]), ], size = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "cex"], shape = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "pch"], color = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "col"])
            }
        }
        p = p + scale_colour_manual(values = unique(col)[match(levels(factor(as.character(df$Block))),
            levels(df$Block))], name = legend.title, breaks = levels(df$Block))
        p = p + scale_x_continuous(limits = c(-1, 1)) + scale_y_continuous(limits = c(-1,
            1))
        p = p + facet_wrap(~Overlap, ncol = 2, as.table = TRUE)
        if (!legend) {
            p = p + theme(legend.position = "none")
        }
        else {
            p = p + guides(colour = guide_legend(override.aes = list(shape = 19,
                size = unique(df$cex))))
        }
        if (abline)
            p = p + geom_vline(aes(xintercept = 0), linetype = 2,
                colour = "darkgrey") + geom_hline(aes(yintercept = 0),
                linetype = 2, colour = "darkgrey")
        for (i in c("Main circle", "Inner circle")) {
            p = p + geom_path(data = subset(circle, Circle ==
                i), aes_string(x = "x", y = "y"),
                color = "Black")
        }
        print(p)
    }
    if (style == "lattice") {
        legend.lattice = list(space = "right", title = legend.title,
            cex.title = 1.25, points = list(col = unique(df$col),
                cex = unique(df$cex), pch = unique(df$pch)),
            text = list(blocks))
        if (overlap) {
            p = xyplot(y ~ x | Overlap, data = df, xlab = X.label,
                ylab = Y.label, main = title, scales = list(x = list(relation = "free",
                  limits = c(-1, 1)), y = list(relation = "free",
                  limits = c(-1, 1))), key = if (legend) {
                  legend.lattice
                }
                else {
                  NULL
                }, panel = function(x, y, ...) {
                  if (abline) {
                    panel.abline(v = 0, lty = 2, col = "darkgrey")
                    panel.abline(h = 0, lty = 2, col = "darkgrey")
                  }
                  for (i in seq_len(length(var.names))) {
                    if (var.names[i]) {
                      panel.text(x = df[c((ind.group[i] + 1):ind.group[i +
                        1]), "x"], y = df[c((ind.group[i] +
                        1):ind.group[i + 1]), "y"], df[c((ind.group[i] +
                        1):ind.group[i + 1]), "names"],
                        col = df[c((ind.group[i] + 1):ind.group[i +
                          1]), "col"], cex = df[c((ind.group[i] +
                          1):ind.group[i + 1]), "cex"],
                        font = df[c((ind.group[i] + 1):ind.group[i +
                          1]), "font"])
                    }
                    else {
                      panel.points(x = df[c((ind.group[i] + 1):ind.group[i +
                        1]), "x"], y = df[c((ind.group[i] +
                        1):ind.group[i + 1]), "y"], col = df[c((ind.group[i] +
                        1):ind.group[i + 1]), "col"], cex = df[c((ind.group[i] +
                        1):ind.group[i + 1]), "cex"], pch = df[c((ind.group[i] +
                        1):ind.group[i + 1]), "pch"])
                    }
                  }
                })
            print(p)
            panels = trellis.currentLayout(which = "panel")
            ind = which(panels == 1, arr.ind = TRUE)
            trellis.focus("panel", ind[2], ind[1], highlight = FALSE)
            for (i in seq_len(length(c("Main circle", "Inner circle")))) {
                panel.lines(x = circle[circle$Circle %in% c("Main circle",
                  "Inner circle")[i], "x"], y = circle[circle$Circle %in%
                  c("Main circle", "Inner circle")[i],
                  "y"], col = "black")
            }
            trellis.unfocus()
        }
        else {
            p = xyplot(y ~ x | Block, data = df, xlab = X.label,
                ylab = Y.label, main = title, as.table = TRUE,
                scales = list(x = list(relation = "free",
                  limits = c(-1, 1)), y = list(relation = "free",
                  limits = c(-1, 1))), col = "white", key = if (legend) {
                  legend.lattice
                }
                else {
                  NULL
                }, )
            print(p)
            panels = trellis.currentLayout(which = "panel")
            for (k in seq_len(length(cord.X))) {
                ind = which(panels == k, arr.ind = TRUE)
                trellis.focus("panel", ind[2], ind[1],
                  highlight = FALSE)
                if (var.names[k]) {
                  panel.text(x = df[c((ind.group[k] + 1):ind.group[k +
                    1]), "x"], y = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "y"], df[c((ind.group[k] +
                    1):ind.group[k + 1]), "names"], col = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "col"], cex = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "cex"], font = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "font"])
                }
                else {
                  panel.points(x = df[c((ind.group[k] + 1):ind.group[k +
                    1]), "x"], y = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "y"], col = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "col"], cex = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "cex"], pch = df[c((ind.group[k] +
                    1):ind.group[k + 1]), "pch"])
                }
                for (i in seq_len(length(c("Main circle",
                  "Inner circle")))) {
                  panel.lines(x = circle[circle$Circle %in% c("Main circle",
                    "Inner circle")[i], "x"], y = circle[circle$Circle %in%
                    c("Main circle", "Inner circle")[i],
                    "y"], col = "black")
                }
            }
            trellis.unfocus()
        }
    }
    if (style == "graphics") {
        if (overlap) {
            if (legend) {
                opar = par(no.readonly = TRUE)
                par(mai = c(1.36, 1.093333, 1.093333, max(strwidth("Legend",
                  "inches"), max(strwidth(blocks, "inches")) +
                  0.3) + 0.2), xpd = TRUE)
            }
            plot(df$x, df$y, type = "n", xlab = X.label,
                ylab = Y.label, main = "", xlim = c(-1,
                  1), ylim = c(-1, 1))
            for (i in seq_len(length(var.names))) {
                if (var.names[i]) {
                  text(x = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "x"], y = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "y"], labels = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "names"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], cex = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"], font = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "font"])
                }
                else {
                  points(x = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "x"], y = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "y"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], cex = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"], pch = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "pch"])
                }
            }
            if (legend)
                legend(x = 1.09, y = 0.2, legend = blocks, title = legend.title,
                  col = unique(df$col), pch = unique(df$pch),
                  pt.cex = unique(df$cex), bty = "n")
            if (abline)
                abline(v = 0, h = 0, lty = 2, xpd = FALSE)
            for (i in c("Main circle", "Inner circle")) {
                lines(x = circle[circle$Circle == i, "x"],
                  y = circle[circle$Circle == i, "y"],
                  col = "black")
            }
            title(title)
            if (legend)
                par(mai = opar$mai, xpd = opar$xpd)
        }
        else {
            opar <- par()[!names(par()) %in% c("cin", "cra",
                "csi", "cxy", "din", "page")]
            mat = matrix(seq_len((ceiling(length(cord.X)/2) *
                2)), ceiling(length(cord.X)/2), min(length(cord.X),
                2), byrow = TRUE)
            if (legend) {
                mat = matrix(rep(mat, each = 2), nrow = nrow(mat),
                  byrow = TRUE)
                mat = cbind(mat, rep(max(mat) + 1, nrow(mat)))
            }
            layout(mat)
            for (k in seq_len(length(cord.X))) {
                plot(df[df$Block %in% paste0("Block: ",
                  blocks[k]), "x"], df[df$Block %in% paste0("Block: ",
                  blocks[k]), "y"], type = "n", xlab = X.label,
                  ylab = Y.label, main = paste0("Block: ",
                    blocks[k]), xlim = c(-1, 1), ylim = c(-1,
                    1))
                if (var.names[k]) {
                  text(x = df[df$Block %in% paste0("Block: ",
                    blocks[k]), "x"], y = df[df$Block %in%
                    paste0("Block: ", blocks[k]), "y"],
                    labels = df[df$Block %in% paste0("Block: ",
                      blocks[k]), "names"], col = df[df$Block %in%
                      paste0("Block: ", blocks[k]), "col"],
                    cex = df[df$Block %in% paste0("Block: ",
                      blocks[k]), "cex"], font = df[df$Block %in%
                      paste0("Block: ", blocks[k]), "font"])
                }
                else {
                  points(x = df[df$Block %in% paste0("Block: ",
                    blocks[k]), "x"], y = df[df$Block %in%
                    paste0("Block: ", blocks[k]), "y"],
                    col = df[df$Block %in% paste0("Block: ",
                      blocks[k]), "col"], cex = df[df$Block %in%
                      paste0("Block: ", blocks[k]), "cex"],
                    pch = df[df$Block %in% paste0("Block: ",
                      blocks[k]), "pch"])
                }
                if (abline)
                  abline(v = 0, h = 0, lty = 2, xpd = FALSE)
                for (i in c("Main circle", "Inner circle")) {
                  lines(x = circle[circle$Circle == i, "x"],
                    y = circle[circle$Circle == i, "y"],
                    col = "black")
                }
            }
            title(title, outer = TRUE, line = -1)
            if (length(cord.X) != max(mat) & length(cord.X) !=
                1) {
                for (i in seq_len((max(mat) - length(cord.X)))) {
                  plot(1, 1, type = "n", axes = FALSE,
                    ann = FALSE)
                }
            }
            if (legend)
                legend("center", legend = blocks, title = legend.title,
                  col = unique(df$col), pch = unique(df$pch),
                  cex = unique(df$cex), bty = "n")
            par(opar)
        }
    }
    if (style == "3d") {
        if (requireNamespace("rgl") == FALSE)
            stop("the rgl package is required for 3d plots")
        rgl::open3d()
        rgl::par3d(windowRect = c(500, 30, 1100, 630))
        Sys.sleep(0.5)
        if (!is.null(title)) {
            mat = matrix(seq_len(2), 2)
            rgl::layout3d(mat, heights = c(1, 10), model = "inherit")
            rgl::next3d()
            rgl::text3d(0, 0, 0, title)
            rgl::next3d()
        }
        rgl::par3d(userMatrix = rgl::rotationMatrix(pi/80, 1,
            -1/(100 * pi), 0))
        if (legend) {
            rgl::legend3d(x = "right", legend = blocks,
                col = unique(col), pch = rep(16, length(unique(pch))),
                pt.cex = unique(cex), bty = "n")
        }
        if (any(axes.box == "axes") || any(axes.box ==
            "all"))
            rgl::axes3d(c("x", "y", "z"), pos = c(0,
                0, 0), nticks = 2, at = c(-1.2, 1.2), tick = FALSE,
                labels = "")
        for (i in seq_len(length(var.names))) {
            if (var.names[i]) {
                rgl::text3d(x = df[c((ind.group[i] + 1):ind.group[i +
                  1]), "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                  1]), "y"], z = df[c((ind.group[i] + 1):ind.group[i +
                  1]), "z"], texts = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "names"], color = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "col"], cex = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "cex"], font = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "font"])
            }
            else {
                switch(unique(df[c((ind.group[i] + 1):ind.group[i +
                  1]), "pch"]), sphere = rgl::plot3d(x = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "x"], y = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "y"], z = df[c((ind.group[i] +
                  1):ind.group[i + 1]), "z"], type = "s",
                  col = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"], radius = cex/20,
                  add = TRUE), tetra = rgl::shapelist3d(rgl::tetrahedron3d(),
                  x = df[c((ind.group[i] + 1):ind.group[i + 1]),
                    "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "y"], z = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "z"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"]/25), cube = rgl::shapelist3d(rgl::cube3d(),
                  x = df[c((ind.group[i] + 1):ind.group[i + 1]),
                    "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "y"], z = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "z"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"]/30), octa = rgl::shapelist3d(rgl::octahedron3d(),
                  x = df[c((ind.group[i] + 1):ind.group[i + 1]),
                    "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "y"], z = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "z"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"]/17), icosa = rgl::shapelist3d(rgl::icosahedron3d(),
                  x = df[c((ind.group[i] + 1):ind.group[i + 1]),
                    "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "y"], z = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "z"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"]/20), dodeca = rgl::shapelist3d(rgl::dodecahedron3d(),
                  x = df[c((ind.group[i] + 1):ind.group[i + 1]),
                    "x"], y = df[c((ind.group[i] + 1):ind.group[i +
                    1]), "y"], z = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "z"], col = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "col"], size = df[c((ind.group[i] +
                    1):ind.group[i + 1]), "cex"]/20))
            }
        }
        rgl::par3d(cex = 0.8)
        if (any(axes.box == "axes") || any(axes.box ==
            "all")) {
            if (any(label.axes.box == "axes") || any(label.axes.box ==
                "both")) {
                rgl::text3d(1.2, -0.05, 0, texts = X.label, cex = 0.8,
                  color = "black")
                rgl::text3d(0, 1.27, 0, texts = Y.label, cex = 0.8,
                  color = "black")
                rgl::text3d(0, -0.05, 1.2, texts = Z.label, cex = 0.8,
                  color = "black")
            }
            X = c(1.2, 1.09, 1.09, 1.2, 1.09, 1.09, 1.2, 1.09,
                1.09, 1.2, 1.09, 1.09, 0, 0, 0, 0, 0.035, -0.035,
                0, 0.035 * sin(pi/4), -0.035 * sin(pi/4), 0,
                0.035 * sin(pi/4), -0.035 * sin(pi/4), 0, 0,
                0, 0, 0, 0, 0, 0.035, -0.035, 0, 0.035 * sin(pi/4),
                -0.035 * sin(pi/4))
            Y = c(0, 0, 0, 0, 0, 0, 0, 0.035, -0.035, 0, 0.035 *
                sin(pi/4), -0.035 * sin(pi/4), 1.2, 1.09, 1.09,
                1.2, 1.09, 1.09, 1.2, 1.09, 1.09, 1.2, 1.09,
                1.09, 0, 0.035, -0.035, 0, 0, 0, 0, 0.035 * sin(pi/4),
                -0.035 * sin(pi/4), 0, -0.035 * sin(pi/4), 0.035 *
                  sin(pi/4))
            Z = c(0, 0.035, -0.035, 0, 0.035, -0.035, 0, 0, 0,
                0, 0.035 * sin(pi/4), -0.035 * sin(pi/4), 0,
                0.035, -0.035, 0, 0, 0, 0, 0.035 * sin(pi/4),
                -0.035 * sin(pi/4), 0, -0.035 * sin(pi/4), 0.035 *
                  sin(pi/4), 1.2, 1.09, 1.09, 1.2, 1.09, 1.09,
                1.2, 1.09, 1.09, 1.2, 1.09, 1.09)
            rgl::triangles3d(x = X, y = Y, z = Z, col = "black")
        }
        rgl::points3d(1.2, 0, 0, size = 0.1, alpha = 0)
        rgl::points3d(0, 1.2, 0, size = 0.1, alpha = 0)
        rgl::points3d(0, 0, 1.2, size = 0.1, alpha = 0)
        rgl::points3d(-1.2, 0, 0, size = 0.1, alpha = 0)
        rgl::points3d(0, -1.2, 0, size = 0.1, alpha = 0)
        rgl::points3d(0, 0, -1.2, size = 0.1, alpha = 0)
        rgl::spheres3d(0, 0, 0, radius = rad.in, front = "fill",
            back = "fill", emission = gray(0.9), alpha = 0.4)
        rgl::spheres3d(0, 0, 0, radius = rad.in, front = "line",
            back = "line", emission = gray(0.9))
        if (any(axes.box == "box") || any(axes.box == "all")) {
            rgl::axes3d(marklen = 25)
            rgl::box3d()
            if (any(label.axes.box == "box") || any(label.axes.box ==
                "both")) {
                rgl::mtext3d(X.label, "x-+", line = 1)
                rgl::mtext3d(Y.label, "y-+", line = 1.5)
                rgl::mtext3d(Z.label, "z+-", line = 1)
            }
        }
        if (any(axes.box == "bbox") || any(axes.box ==
            "all")) {
            rgl::bbox3d(color = c("#333377", "black"),
                emission = gray(0.5), specular = gray(0.1), shininess = 5,
                alpha = 0.8, marklen = 25)
            if (any(label.axes.box == "box") || any(label.axes.box ==
                "both")) {
                rgl::mtext3d(X.label, "x-+", line = 1)
                rgl::mtext3d(Y.label, "y-+", line = 1.5)
                rgl::mtext3d(Z.label, "z+-", line = 1)
            }
        }
    }
    if (plot) {
        return(invisible(df))
    }
    else return(df)
}

```

Extended base heatmap with color scale bar

```{r}
my.heatmap <-
function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL,
    distfun = dist, hclustfun = hclust, reorderfun = function(d,
        w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv,
        "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE,
    margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.20000000000000001 +
        1/log10(nr), cexCol = 0.20000000000000001 + 1/log10(nc),
    labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL,
    keep.dendro = FALSE, verbose = getOption("verbose"), legend=TRUE, zlim=range(x,na.rm=TRUE), col = hcl.colors(12, "YlOrRd", rev = TRUE),  ...)
{
    scale <- if (symm && missing(scale))
        "none"
    else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x))
        stop("'x' must be a numeric matrix")
    nr <- di[1L]
    nc <- di[2L]
    if (nr <= 1 || nc <= 1)
        stop("'x' must have at least 2 rows and 2 columns")
    if (!is.numeric(margins) || length(margins) != 2L)
        stop("'margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (!doRdend && identical(Colv, "Rowv"))
        doCdend <- FALSE
    if (is.null(Rowv))
        Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv))
        Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "dendrogram"))
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x))
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv)
                ddr <- reorderfun(ddr, Rowv)
        }
        if (nr != length(rowInd <- order.dendrogram(ddr)))
            stop("row dendrogram ordering gave index of wrong length")
    }
    else rowInd <- 1L:nr
    if (doCdend) {
        if (inherits(Colv, "dendrogram"))
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc)
                stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm)
                x
            else t(x)))
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv)
                ddc <- reorderfun(ddc, Colv)
        }
        if (nc != length(colInd <- order.dendrogram(ddc)))
            stop("column dendrogram ordering gave index of wrong length")
    }
    else colInd <- 1L:nc
    x <- x[rowInd, colInd]
    labRow <- if (is.null(labRow))
        if (is.null(rownames(x)))
            (1L:nr)[rowInd]
        else rownames(x)
    else labRow[rowInd]
    labCol <- if (is.null(labCol))
        if (is.null(colnames(x)))
            (1L:nc)[colInd]
        else colnames(x)
    else labCol[colInd]
    if (scale == "row") {
        x <- sweep(x, 1L, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 1L, sd, na.rm = na.rm)
        x <- sweep(x, 1L, sx, "/", check.margin = FALSE)
    }
    else if (scale == "column") {
        x <- sweep(x, 2L, colMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 2L, sd, na.rm = na.rm)
        x <- sweep(x, 2L, sx, "/", check.margin = FALSE)
    }
    lmat <- rbind(c(NA, 3), 2:1)
    lwid <- c(if (doRdend) 1 else 0.050000000000000003, 4)
    lhei <- c((if (doCdend) 1 else 0.050000000000000003) + if (!is.null(main)) 0.20000000000000001 else 0,
        4)
    if (!missing(ColSideColors)) {
        if (!is.character(ColSideColors) || length(ColSideColors) !=
            nc)
            stop("'ColSideColors' must be a character vector of length ncol(x)")
        lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lhei <- c(lhei[1L], 0.20000000000000001, lhei[2L])
    }
    if (!missing(RowSideColors)) {
        if (!is.character(RowSideColors) || length(RowSideColors) !=
            nr)
            stop("'RowSideColors' must be a character vector of length nrow(x)")
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1),
            1), lmat[, 2] + 1)
        lwid <- c(lwid[1L], 0.20000000000000001, lwid[2L])
    }
    lmat[is.na(lmat)] <- 0
    if(legend) lmat[1,1] <- max(lmat)+1
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei,
            "; lmat=\n")
        print(lmat)
    }
    dev.hold()
    on.exit(dev.flush())
    op <- par(no.readonly = TRUE)
    on.exit(par(op), add = TRUE)
    layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    if (!missing(RowSideColors)) {
        par(mar = c(margins[1L], 0, 0, 0.5))
        image(rbind(if (revC)
            nr:1L
        else 1L:nr), col = RowSideColors[rowInd], axes = FALSE)
    }
    if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2L]))
        image(cbind(1L:nc), col = ColSideColors[colInd], axes = FALSE)
    }
    par(mar = c(margins[1L], 0, 0, margins[2L]))
    if (!symm || scale != "none")
        x <- t(x)
    if (revC) {
        iy <- nr:1
        if (doRdend)
            ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1L:nr
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 +
        c(0, nr), axes = FALSE, xlab = "", ylab = "", zlim=zlim, col=col, ...)
    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0,
        cex.axis = cexCol)
    if (!is.null(xlab))
        mtext(xlab, side = 1, line = margins[1L] - 1.25)
    axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0,
        cex.axis = cexRow)
    if (!is.null(ylab))
        mtext(ylab, side = 4, line = margins[2L] - 1.25)
    if (!missing(add.expr))
        eval.parent(substitute(add.expr))
    par(mar = c(margins[1L], 0, 0, 0))
    if (doRdend)
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
    else frame()
    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2L]))
    if (doCdend)
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
    else if (!is.null(main))
        frame()
    if (!is.null(main)) {
        par(xpd = NA)
        title(main, cex.main = 1.5 * op[["cex.main"]])
    }
        colorBar <- function(n,col,zlim){
        ColorLevels <- seq(zlim[1],zlim[2],length.out=length(col))
        labels <- seq(zlim[1],zlim[2],length.out=5)
        labels <- format(round(labels,2))
        par(mar=c(0,1,2,3))
        image(t(matrix(ColorLevels,ncol=1)),axes=F,col=col)
        axis(4,at=seq(0,1,length.out=5),tick=F,labels=labels,cex.axis=.9,las=2,line=-.5)
        mtext("Scale",side=3,outer=F,cex=.6,line=.4)
    }

    if(legend) colorBar(6,col,zlim)
    invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro &&
        doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}
if(interactive()){
my.heatmap(r,col=cols,zlim=c(-1,1),verbose=TRUE,ColSideColors=rep("red",ncol(r)),RowSideColors=rep("blue",nrow(r)), main="Naslov")
my.heatmap(r,col=cols,zlim=c(-1,1),verbose=TRUE, main="Naslov", legend=TRUE)
my.heatmap(r,col=cols,verbose=TRUE,ColSideColors=rep("red",ncol(r)),RowSideColors=rep("blue",nrow(r)))
}
```

```{r my.cor}

my.cor=function (x, y = NULL, use = "everything", method = c("spearman",
    "kendall", "pearson"))
{
    na.method <- pmatch(use, c("all.obs", "complete.obs",
        "pairwise.complete.obs", "everything", "na.or.complete"))
    if (is.na(na.method))
        stop("invalid 'use' argument")
    method <- match.arg(method)
    if (is.data.frame(y))
        y <- as.matrix(y)
    if (is.data.frame(x))
        x <- as.matrix(x)
    if (!is.matrix(x) && is.null(y))
        stop("supply both 'x' and 'y' or a matrix-like 'x'")
    if (!(is.numeric(x) || is.logical(x)))
        stop("'x' must be numeric")
    stopifnot(is.atomic(x))
    if (!is.null(y)) {
        if (!(is.numeric(y) || is.logical(y)))
            stop("'y' must be numeric")
        stopifnot(is.atomic(y))
    }
    Rank <- function(u) {
        if (length(u) == 0L)
            u
        else if (is.matrix(u)) {
            if (nrow(u) > 1L)
                apply(u, 2L, rank, na.last = "keep")
            else row(u)
        }
        else rank(u, na.last = "keep")
    }
    if (method == "pearson")
        .Call(stats:::C_cor, x, y, na.method, FALSE)
    else if (na.method %in% c(2L, 5L)) {
        if (is.null(y)) {
            .Call(stats:::C_cor, Rank(na.omit(x)), NULL, na.method, method ==
                "kendall")
        }
        else {
            nas <- attr(na.omit(cbind(x, y)), "na.action")
            dropNA <- function(x, nas) {
                if (length(nas)) {
                  if (is.matrix(x))
                    x[-nas, , drop = FALSE]
                  else x[-nas]
                }
                else x
            }
            .Call(stats:::C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y,
                nas)), na.method, method == "kendall")
        }
    }
    else if (na.method != 3L) {
        x <- Rank(x)
        if (!is.null(y))
            y <- Rank(y)
        .Call(stats:::C_cor, x, y, na.method, method == "kendall")
    }
    else {
        if (is.null(y)) {
            ncy <- ncx <- ncol(x)
            if (ncx == 0)
                stop("'x' is empty")
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(i)) {
                  x2 <- x[, i]
                  y2 <- x[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok))
                    .Call(stats:::C_cor, x2, y2, 1L, method == "kendall")
                  else NA
                }
            }
            r <- r + t(r) - diag(diag(r))
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(x)
            r
        }
        else {
            if (length(x) == 0L || length(y) == 0L)
                stop("both 'x' and 'y' must be non-empty")
            matrix_result <- is.matrix(x) || is.matrix(y)
            if (!is.matrix(x))
                x <- matrix(x, ncol = 1L)
            if (!is.matrix(y))
                y <- matrix(y, ncol = 1L)
            ncx <- ncol(x)
            ncy <- ncol(y)
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(ncy)) {
                  x2 <- x[, i]
                  y2 <- y[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok))
                    .Call(stats:::C_cor, x2, y2, 1L, method == "kendall")
                  else NA
                }
            }
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(y)
            if (matrix_result)
                r
            else drop(r)
        }
    }
}

```

Extended base heatmap with color scale bar

```{r }
my.heatmap <-
function (x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL,
    distfun = dist, hclustfun = hclust, reorderfun = function(d,
        w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv,
        "Rowv"), scale = c("row", "column", "none"), na.rm = TRUE,
    margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.20000000000000001 +
        1/log10(nr), cexCol = 0.20000000000000001 + 1/log10(nc),
    labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL,
    keep.dendro = FALSE, verbose = getOption("verbose"), legend=TRUE, zlim=range(x,na.rm=TRUE), col = hcl.colors(12, "YlOrRd", rev = TRUE),  ...)
{
    scale <- if (symm && missing(scale))
        "none"
    else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x))
        stop("'x' must be a numeric matrix")
    nr <- di[1L]
    nc <- di[2L]
    if (nr <= 1 || nc <= 1)
        stop("'x' must have at least 2 rows and 2 columns")
    if (!is.numeric(margins) || length(margins) != 2L)
        stop("'margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (!doRdend && identical(Colv, "Rowv"))
        doCdend <- FALSE
    if (is.null(Rowv))
        Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv))
        Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "dendrogram"))
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x))
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv)
                ddr <- reorderfun(ddr, Rowv)
        }
        if (nr != length(rowInd <- order.dendrogram(ddr)))
            stop("row dendrogram ordering gave index of wrong length")
    }
    else rowInd <- 1L:nr
    if (doCdend) {
        if (inherits(Colv, "dendrogram"))
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc)
                stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm)
                x
            else t(x)))
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv)
                ddc <- reorderfun(ddc, Colv)
        }
        if (nc != length(colInd <- order.dendrogram(ddc)))
            stop("column dendrogram ordering gave index of wrong length")
    }
    else colInd <- 1L:nc
    x <- x[rowInd, colInd]
    labRow <- if (is.null(labRow))
        if (is.null(rownames(x)))
            (1L:nr)[rowInd]
        else rownames(x)
    else labRow[rowInd]
    labCol <- if (is.null(labCol))
        if (is.null(colnames(x)))
            (1L:nc)[colInd]
        else colnames(x)
    else labCol[colInd]
    if (scale == "row") {
        x <- sweep(x, 1L, rowMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 1L, sd, na.rm = na.rm)
        x <- sweep(x, 1L, sx, "/", check.margin = FALSE)
    }
    else if (scale == "column") {
        x <- sweep(x, 2L, colMeans(x, na.rm = na.rm), check.margin = FALSE)
        sx <- apply(x, 2L, sd, na.rm = na.rm)
        x <- sweep(x, 2L, sx, "/", check.margin = FALSE)
    }
    lmat <- rbind(c(NA, 3), 2:1)
    lwid <- c(if (doRdend) 1 else 0.050000000000000003, 4)
    lhei <- c((if (doCdend) 1 else 0.050000000000000003) + if (!is.null(main)) 0.20000000000000001 else 0,
        4)
    if (!missing(ColSideColors)) {
        if (!is.character(ColSideColors) || length(ColSideColors) !=
            nc)
            stop("'ColSideColors' must be a character vector of length ncol(x)")
        lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lhei <- c(lhei[1L], 0.20000000000000001, lhei[2L])
    }
    if (!missing(RowSideColors)) {
        if (!is.character(RowSideColors) || length(RowSideColors) !=
            nr)
            stop("'RowSideColors' must be a character vector of length nrow(x)")
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1),
            1), lmat[, 2] + 1)
        lwid <- c(lwid[1L], 0.20000000000000001, lwid[2L])
    }
    lmat[is.na(lmat)] <- 0
    if(legend) lmat[1,1] <- max(lmat)+1
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei,
            "; lmat=\n")
        print(lmat)
    }
    dev.hold()
    on.exit(dev.flush())
    op <- par(no.readonly = TRUE)
    on.exit(par(op), add = TRUE)
    layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    if (!missing(RowSideColors)) {
        par(mar = c(margins[1L], 0, 0, 0.5))
        image(rbind(if (revC)
            nr:1L
        else 1L:nr), col = RowSideColors[rowInd], axes = FALSE)
    }
    if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2L]))
        image(cbind(1L:nc), col = ColSideColors[colInd], axes = FALSE)
    }
    par(mar = c(margins[1L], 0, 0, margins[2L]))
    if (!symm || scale != "none")
        x <- t(x)
    if (revC) {
        iy <- nr:1
        if (doRdend)
            ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1L:nr
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 +
        c(0, nr), axes = FALSE, xlab = "", ylab = "", zlim=zlim, col=col, ...)
    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0,
        cex.axis = cexCol)
    if (!is.null(xlab))
        mtext(xlab, side = 1, line = margins[1L] - 1.25)
    axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0,
        cex.axis = cexRow)
    if (!is.null(ylab))
        mtext(ylab, side = 4, line = margins[2L] - 1.25)
    if (!missing(add.expr))
        eval.parent(substitute(add.expr))
    par(mar = c(margins[1L], 0, 0, 0))
    if (doRdend)
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
    else frame()
    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2L]))
    if (doCdend)
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
    else if (!is.null(main))
        frame()
    if (!is.null(main)) {
        par(xpd = NA)
        title(main, cex.main = 1.5 * op[["cex.main"]])
    }
        colorBar <- function(n,col,zlim){
        ColorLevels <- seq(zlim[1],zlim[2],length.out=length(col))
        labels <- seq(zlim[1],zlim[2],length.out=5)
        labels <- format(round(labels,2))
        par(mar=c(0,1,2,3))
        image(t(matrix(ColorLevels,ncol=1)),axes=F,col=col)
        axis(4,at=seq(0,1,length.out=5),tick=F,labels=labels,cex.axis=.9,las=2,line=-.5)
        mtext("Scale",side=3,outer=F,cex=.6,line=.4)
    }

    if(legend) colorBar(6,col,zlim)
    invisible(list(rowInd = rowInd, colInd = colInd, Rowv = if (keep.dendro &&
        doRdend) ddr, Colv = if (keep.dendro && doCdend) ddc))
}
if(interactive()){
my.heatmap(r,col=cols,zlim=c(-1,1),verbose=TRUE,ColSideColors=rep("red",ncol(r)),RowSideColors=rep("blue",nrow(r)), main="Naslov")
my.heatmap(r,col=cols,zlim=c(-1,1),verbose=TRUE, main="Naslov", legend=TRUE)
my.heatmap(r,col=cols,verbose=TRUE,ColSideColors=rep("red",ncol(r)),RowSideColors=rep("blue",nrow(r)))
}
```

```{r eval=FALSE}
my.cor=function (x, y = NULL, use = "everything", method = c("spearman",
    "kendall", "pearson"))
{
    na.method <- pmatch(use, c("all.obs", "complete.obs",
        "pairwise.complete.obs", "everything", "na.or.complete"))
    if (is.na(na.method))
        stop("invalid 'use' argument")
    method <- match.arg(method)
    if (is.data.frame(y))
        y <- as.matrix(y)
    if (is.data.frame(x))
        x <- as.matrix(x)
    if (!is.matrix(x) && is.null(y))
        stop("supply both 'x' and 'y' or a matrix-like 'x'")
    if (!(is.numeric(x) || is.logical(x)))
        stop("'x' must be numeric")
    stopifnot(is.atomic(x))
    if (!is.null(y)) {
        if (!(is.numeric(y) || is.logical(y)))
            stop("'y' must be numeric")
        stopifnot(is.atomic(y))
    }
    Rank <- function(u) {
        if (length(u) == 0L)
            u
        else if (is.matrix(u)) {
            if (nrow(u) > 1L)
                apply(u, 2L, rank, na.last = "keep")
            else row(u)
        }
        else rank(u, na.last = "keep")
    }
    if (method == "pearson")
        .Call(stats:::C_cor, x, y, na.method, FALSE)
    else if (na.method %in% c(2L, 5L)) {
        if (is.null(y)) {
            .Call(stats:::C_cor, Rank(na.omit(x)), NULL, na.method, method ==
                "kendall")
        }
        else {
            nas <- attr(na.omit(cbind(x, y)), "na.action")
            dropNA <- function(x, nas) {
                if (length(nas)) {
                  if (is.matrix(x))
                    x[-nas, , drop = FALSE]
                  else x[-nas]
                }
                else x
            }
            .Call(stats:::C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y,
                nas)), na.method, method == "kendall")
        }
    }
    else if (na.method != 3L) {
        x <- Rank(x)
        if (!is.null(y))
            y <- Rank(y)
        .Call(stats:::C_cor, x, y, na.method, method == "kendall")
    }
    else {
        if (is.null(y)) {
            ncy <- ncx <- ncol(x)
            if (ncx == 0)
                stop("'x' is empty")
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(i)) {
                  x2 <- x[, i]
                  y2 <- x[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok))
                    .Call(stats:::C_cor, x2, y2, 1L, method == "kendall")
                  else NA
                }
            }
            r <- r + t(r) - diag(diag(r))
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(x)
            r
        }
        else {
            if (length(x) == 0L || length(y) == 0L)
                stop("both 'x' and 'y' must be non-empty")
            matrix_result <- is.matrix(x) || is.matrix(y)
            if (!is.matrix(x))
                x <- matrix(x, ncol = 1L)
            if (!is.matrix(y))
                y <- matrix(y, ncol = 1L)
            ncx <- ncol(x)
            ncy <- ncol(y)
            r <- matrix(0, nrow = ncx, ncol = ncy)
            for (i in seq_len(ncx)) {
                for (j in seq_len(ncy)) {
                  x2 <- x[, i]
                  y2 <- y[, j]
                  ok <- complete.cases(x2, y2)
                  x2 <- rank(x2[ok])
                  y2 <- rank(y2[ok])
                  r[i, j] <- if (any(ok))
                    .Call(stats:::C_cor, x2, y2, 1L, method == "kendall")
                  else NA
                }
            }
            rownames(r) <- colnames(x)
            colnames(r) <- colnames(y)
            if (matrix_result)
                r
            else drop(r)
        }
    }
}
```


```{r my functions,echo=FALSE}
my.write.table <- function(x, file="",label="", col.names=NA, sep="\t", meta = TRUE, ...){
if(meta) {
catln(
  "#\tObject:\t", deparse(substitute(x)),
"\n#\tLabel:\t", label,
"\n#\tFile :\t", file,
"\n#\tproject :\t", getMeta(.pmeta,"project"),
"\n#\tInvestigation :\t", getMeta(.imeta,"Investigation"),
"\n#\tStudy :\t", getMeta(.smeta,"Study"),
"\n#\tAssay :\t", getMeta(.ameta,"Assay"),
"\n#\tReport :\t", outputFile,
"\n#\tDate:\t", as.character(Sys.Date()),
"\n#"
   , file=file)
}
#
write.table(x, file=file, col.names=col.names, sep=sep, append =  meta, ...)
catln(
" Object:", deparse(substitute(x)),
"\\\\\n  Label:", label,
"\\\\\n  File :\\\\", paste0("\n\\href{run:"
, gsub("\\\\","\\\\\\\\",normalizePath(file))
, "}{",file,"}")
)
}
#####
my.head <- function(x, n=6, m=5, ...) {
print(head(x[ ,1:min(ncol(x),m)], n, ...))
dim(x)
}
head.list <- function(x, ...) lapply(x, head, ...)
tail.list <- function(x, ...) lapply(x, tail, ...)
catln <- function(...) cat(...,"\n")
.test <- function(...) {if(.testing) {cat(" > > > ", deparse (substitute (...)), " = \n")
print(...)
}}
.testing <- FALSE
##bla
##
## View functions
```


```{r }

#' Function to extract network edges
#'
#' @param x network (igraph)
#' @param cnames vector with (3) column names of the result
#'    (e.g. c("from","to","weight")).
#' @return three coluimn dataframe with edges,
#'    described as node names and weight for each edge.
#' @export
#' @seealso `\link{funkcija`}
#' @note
#' @references
#' @keywords
#' @title
#' @author Andrej Blejec \email{andrej.blejec@nib.si}
#' @examples
#'

extractEdges <- function(x, cnames=NULL){

    edges <- NULL
    for (i in 1:length(x$gR)){
    e <- x$gR[[i]]
    from <- names(e)
    to <- names(e[[1]])
    w <- x$M[from, to]
    es <- data.frame(from=from,to=to,w=w)
    rownames(es) <- paste(from,to,sep="...")
    edges <- rbind(edges,es)
    }
    if(!is.null(cnames)) colnames(edges) <- cnames
    edges

    }
# Alternative:
#
# e <- data.frame(from=rep(rownames(x), ncol(x)),
#      to=rep(colnames(x),each=nrow(x), w=as.vector(x)),
```

```{r }

#' Function to extract network edges
#'
#' @param x network (igraph)
#' @param cnames vector with (3) column names of the result
#'    (e.g. c("from","to","weight")).
#' @return three coluimn dataframe with edges,
#'    described as node names and weight for each edge.
#' @export
#' @seealso `\link{funkcija`}
#' @note
#' @references
#' @keywords
#' @title
#' @author Andrej Blejec \email{andrej.blejec@nib.si}
#' @examples
#'

extractEdges2 <- function(x, cnames=NULL){

    edges <- NULL
    ind <- grep("^M_",names(x))
    for (i in ind){
    e <- x[[i]]
    from <- rep(rownames(e), ncol(e))
    to <- rep(colnames(e), each=nrow(e))
    group <- names(x)[i]
    w <- e[from, to]
    group1 <- gsub("^M_(.*)_(.*)$","\\1",group)
    gr1 <- substr(group1,1,2)
    group2 <- gsub("^M_(.*)_(.*)$","\\2",group)
    gr2 <- substr(group2,1,2)
        lbl <-     paste(paste(gr1,from,sep="."),paste(gr2,to,sep="."),sep="_")
        es <- data.frame(edge=lbl, group1=group1
        , from=from
        , group2=group2
        , to=to
        , w=as.vector(e))
#        print(head(es))
#        print(head(e))
    rownames(es) <- paste(paste(gr1,from,sep="."),paste(gr2,to,sep="."),sep="_")
    edges <- rbind(edges,es)
    }
    if(!is.null(cnames)) colnames(edges) <- cnames
    edges

    }
# Alternative:
#
# e <- data.frame(from=rep(rownames(x), ncol(x)),
#      to=rep(colnames(x),each=nrow(x), w=as.vector(x)),
```

```{r layout.function}
my.layout <- function(x,...) ly
```


```{r}
my.network <-
function (mat, comp = NULL, blocks = c(1, 2), cutoff = 0, row.names = TRUE,
    col.names = TRUE, block.var.names = TRUE, color.node = NULL,
    shape.node = NULL, cex.node.name = 1, color.edge = color.GreenRed(100),
    lty.edge = "solid", lwd.edge = 1, show.edge.labels = FALSE,
    cex.edge.label = 1, show.color.key = TRUE, symkey = TRUE,
    keysize = c(1, 1), keysize.label = 1, breaks, interactive = FALSE,
    layout.fun = NULL, save = NULL, name.save = NULL)
{
    arg.call = match.call()
    user.arg = names(arg.call)[-1]
    err = tryCatch(mget(names(formals()), sys.frame(sys.nframe())),
        error = function(e) e)
    if ("simpleError" %in% class(err))
        stop(err[[1]], ".", call. = FALSE)
    function.arg = names(mget(names(formals()), sys.frame(sys.nframe())))
    not.arg = !(user.arg %in% function.arg)
    if (any(not.arg)) {
        unused.arg = user.arg[not.arg]
        not.arg = which(not.arg) + 1
        output = rep("", length(not.arg))
        for (i in 1:length(not.arg)) {
            output[i] = paste0(unused.arg[i], " = ", arg.call[[not.arg[i]]])
        }
        output = paste0("(", paste(output, collapse = ", "),
            ").")
        msg = "unused argument "
        if (length(not.arg) > 1)
            msg = "unused arguments "
        stop(msg, output, call. = FALSE)
    }
    if (!is.null(save)) {
        if (!save %in% c("jpeg", "tiff", "png",
            "pdf"))
            stop("'save' must be one of 'jpeg', 'png', 'tiff' or 'pdf'.",
                call. = FALSE)
    }
    if (!is.null(name.save)) {
        if (!is.character(name.save) || length(name.save) > 1)
            stop("'name.save' must be a character.", call. = FALSE)
    }
    else {
        if (!is.null(save))
            name.save = paste0("network_", gsub(".",
                "_", deparse(substitute(mat)), fixed = TRUE))
    }
    if (!is.null(save)) {
        while (dev.cur() > 1) dev.off()
        if (save == "jpeg")
            jpeg(filename = paste0(name.save, ".jpeg"),
                res = 600, width = 4000, height = 4000)
        if (save == "png")
            jpeg(filename = paste0(name.save, ".png"),
                res = 600, width = 4000, height = 4000)
        if (save == "tiff")
            tiff(filename = paste0(name.save, ".tiff"),
                res = 600, width = 4000, height = 4000)
        if (save == "pdf")
            pdf(file = paste0(name.save, ".pdf"))
    }
    class.object = class(mat)
    object.pls = c("mixo_pls", "mixo_spls", "mixo_mlspls")
    object.rcc = "rcc"
    object.blocks = c("sgcca", "rgcca")
    if (!any(class.object %in% c(object.pls, object.rcc, object.blocks,
        "matrix")))
        stop(" 'network' is only implemented for the following objects: matrix, pls, plsda, spls, splsda, rcc, sgcca, rgcca, sgccda",
            call. = FALSE)
    if (any(class.object %in% c(object.rcc, object.pls))) {
        p = ncol(mat$X)
        if (any(class.object == "DA"))
            mat$Y = mat$ind.mat
        q = ncol(mat$Y)
        n = nrow(mat$X)
        ncomp = mat$ncomp
        if (is.null(comp))
            comp = 1:mat$ncomp
        if (length(comp) == 1) {
            if (comp > ncomp) {
                stop("the elements of 'comp' must be smaller than or equal to ",
                  ncomp, ".", call. = FALSE)
            }
            else if (!is.numeric(comp) || comp <= 0) {
                stop("invalid value for 'comp'.", call. = FALSE)
            }
        }
        if (length(comp) > 1) {
            if (length(comp) > ncomp)
                stop("the length of 'comp' must be smaller than or equal to ",
                  ncomp, ".", call. = FALSE)
            if (!is.numeric(comp) || any(comp < 1))
                stop("invalid vector for 'comp'.", call. = FALSE)
            if (any(comp > ncomp))
                stop("the elements of 'comp' must be smaller or equal than ",
                  ncomp, ".", call. = FALSE)
        }
        comp = round(comp)
        row.names.plot = TRUE
        if (is.logical(row.names)) {
            if (!isTRUE(row.names)) {
                row.names.plot = FALSE
            }
            row.names = mat$names$colnames$X
        }
        else {
            row.names = as.vector(row.names)
            if (length(unique(row.names)) != p)
                stop("'row.names' must be a character vector of ",
                  p, " unique entries.", call. = FALSE)
        }
        if (row.names.plot == TRUE) {
            row.names.plot = row.names
        }
        else {
            row.names.plot = rep("", p)
        }
        col.names.plot = TRUE
        if (is.logical(col.names)) {
            if (!isTRUE(col.names)) {
                col.names.plot = FALSE
            }
            col.names = mat$names$colnames$Y
        }
        else {
            col.names = as.vector(col.names)
            if (length(col.names) != q)
                stop("'col.names' must be a character vector of ",
                  q, " unique entries.", call. = FALSE)
        }
        if (col.names.plot == TRUE) {
            col.names.plot = col.names
        }
        else {
            col.names.plot = rep("", q)
        }
        if (any(class.object %in% object.rcc)) {
            bisect = mat$variates$X[, comp] + mat$variates$Y[,
                comp]
            cord.X = cor(mat$X, bisect, use = "pairwise")
            cord.Y = cor(mat$Y, bisect, use = "pairwise")
            mat = cord.X %*% t(cord.Y)
        }
        else if (any(class.object %in% object.pls)) {
            if (all(class(mat) %in% "mixo_pls")) {
                keep.X = rep(TRUE, p)
                keep.Y = rep(TRUE, q)
            }
            else {
                keep.X = apply(abs(mat$loadings$X[, comp, drop = FALSE]),
                  1, sum) > 0
                keep.Y = apply(abs(mat$loadings$Y[, comp, drop = FALSE]),
                  1, sum) > 0
                row.names = row.names[keep.X]
                col.names = col.names[keep.Y]
            }
            if (mat$mode == "canonical") {
                cord.X = cor(mat$X[, keep.X], mat$variates$X[,
                  comp], use = "pairwise")
                cord.Y = cor(mat$Y[, keep.Y], mat$variates$Y[,
                  comp], use = "pairwise")
            }
            else {
                cord.X = cor(mat$X[, keep.X], mat$variates$X[,
                  comp], use = "pairwise")
                cord.Y = cor(mat$Y[, keep.Y], mat$variates$X[,
                  comp], use = "pairwise")
            }
            mat = cord.X %*% t(cord.Y)
        }
    }
    else if (any(class.object %in% object.blocks)) {
        if (any(class.object == "DA")) {
            mat$names$blocks = mat$names$blocks[-mat$indY]
            mat$names$colnames = mat$names$colnames[-mat$indY]
            mat$ncomp = mat$ncomp[-mat$indY]
        }
        if (is.null(blocks)) {
            if (any(mat$ncomp > 1)) {
                blocks = mat$names$blocks[which(mat$ncomp > 1)]
            }
            else {
                stop(("The number of components for each block is 1. The number of components must be superior or equal to 2."),
                  call. = FALSE)
            }
        }
        else if (is.numeric(blocks) & min(blocks) > 0 & max(blocks) <=
            length(mat$names$blocks)) {
            blocks = mat$names$blocks[blocks]
        }
        else if (is.character(blocks)) {
            if (!all(blocks %in% mat$names$blocks))
                stop("One element of 'blocks' does not match with the names of the blocks")
        }
        else {
            stop("Incorrect value for 'blocks", call. = FALSE)
        }
        if (is.null(comp)) {
            comp = vector("list", length(blocks))
            names(comp) = blocks
            for (i in blocks) comp[[i]] = 1:mat$ncomp[i]
        }
        if (is.list(comp)) {
            if (length(comp) != length(blocks))
                stop("'comp' must be either NULL a list of length ",
                  length(blocks), ".", call. = FALSE)
            if (!all(blocks %in% names(comp)))
                stop("names of 'comp' must be from {",
                  paste(blocks, collapse = ", "), "}.",
                  call. = FALSE)
            for (i in blocks) {
                if (any(!is.finite(comp[[i]])))
                  stop("invalid value for 'comp' of the block '",
                    i, "'.", call. = FALSE)
                if (any(comp[[i]] > mat$ncomp[i]))
                  stop("the elements of 'comp' for block '",
                    i, "' must be smaller or equal than ",
                    mat$ncomp[i], ".", call. = FALSE)
                if (any(comp[[i]] < 1))
                  stop("invalid value for 'comp' of the block '",
                    i, "'.", call. = FALSE)
            }
        }
        else {
            stop("'comp' must be either NULL or a list of length ",
                length(blocks), ".", call. = FALSE)
        }
        num.var = unlist(lapply(mat$X[blocks], ncol))
        if (is.logical(block.var.names)) {
            if (length(block.var.names) == 1)
                block.var.names = rep(block.var.names, length(blocks))
            if (length(block.var.names) != length(blocks))
                stop("'block.var.names' must be a logical vector of length 1 or ",
                  length(blocks), ", or a list of length ",
                  length(blocks), ".", call. = FALSE)
            vec = (which(block.var.names == FALSE))
            block.var.names = mat$names$colnames
            for (i in 1:length(blocks)) {
                if (i %in% vec)
                  block.var.names[[blocks[i]]] = rep(" ",
                    length(mat$names$colnames[[blocks[i]]]))
            }
        }
        else {
            if (is.list(block.var.names)) {
                if (length(block.var.names) != length(blocks)) {
                  stop("'block.var.names' must be a logical vector or a list of length ",
                    length(blocks), ".", call. = FALSE)
                }
                else {
                  if (!all(unlist(lapply(block.var.names, is.vector))))
                    stop("each component of 'block.var.names' must be a vector.",
                      call. = FALSE)
                  block.var.names.length = unlist(lapply(block.var.names,
                    length))
                  if (any(block.var.names.length != num.var))
                    stop("components of 'block.var.names' must be vectors of length ",
                      paste(num.var, collapse = ", "),
                      ".", call. = FALSE)
                }
            }
            else {
                stop("'block.var.names' must be either a logical value or a list of length ",
                  length(blocks), ".", call. = FALSE)
            }
        }
        coord = M_block = list()
        j = 1
        if (is(mat, "sgcca")) {
            for (k in blocks) {
                if (length(comp[[k]]) > 1) {
                  keep = (apply(abs(mat$loadings[[k]][, comp[[k]]]),
                    1, sum) > 0)
                }
                else {
                  keep = abs(mat$loadings[[k]][, comp[[k]]]) >
                    0
                }
                coord[[j]] = cor(mat$X[[k]][, keep], mat$variates[[k]][,
                  comp[[k]]], use = "pairwise")
                j = j + 1
            }
        }
        else {
            for (k in blocks) {
                coord[[j]] = cor(mat$X[[k]], mat$variates[[k]][,
                  comp[[k]]], use = "pairwise")
                j = j + 1
            }
        }
        node.X = node.Y = w = NULL
        l = 1
        for (j in 1:(length(blocks) - 1)) {
            for (k in (j + 1):length(blocks)) {
                if (!any(comp[[blocks[j]]] %in% comp[[blocks[k]]]))
                  stop("comp of block ", blocks[j], " is ",
                    comp[[blocks[j]]], " but comp of block ",
                    blocks[k], " is ", comp[[blocks[k]]],
                    call. = FALSE)
                int.comp = intersect(comp[[blocks[j]]], comp[[blocks[k]]])
                object = coord[[j]][, comp[[blocks[j]]] %in%
                  int.comp] %*% t(coord[[k]][, comp[[blocks[k]]] %in%
                  int.comp])
                M_block[[l]] = object
                l = l + 1
                X = rownames(coord[[j]])
                Y = rownames(coord[[k]])
                rep.X = rep(X, each = length(Y))
                rep.Y = rep(Y, length(X))
                node.X = c(node.X, rep.X)
                node.Y = c(node.Y, rep.Y)
                w = c(w, as.vector(t(object)))
            }
        }
    }
    else {
        if (!is.matrix(mat))
            stop("'mat' must be a numeric matrix.", call. = FALSE)
        if (length(dim(mat)) != 2)
            stop("'mat' must be a numeric matrix.")
        if (!is.numeric(mat))
            stop("'mat' must be a numeric matrix.")
        p = nrow(mat)
        q = ncol(mat)
        row.names.plot = TRUE
        if (is.logical(row.names)) {
            if (!isTRUE(row.names)) {
                row.names.plot = FALSE
            }
            row.names = rownames(mat)
        }
        else {
            row.names = as.vector(row.names)
            if (length(row.names) != p)
                stop("'row.names' must be a character vector of ",
                  p, " unique entries.", call. = FALSE)
        }
        if (row.names.plot == TRUE) {
            row.names.plot = row.names
        }
        else {
            row.names.plot = rep("", p)
        }
        col.names.plot = TRUE
        if (is.logical(col.names)) {
            if (!isTRUE(col.names)) {
                col.names.plot = FALSE
            }
            col.names = colnames(mat)
        }
        else {
            col.names = as.vector(col.names)
            if (length(col.names) != q)
                stop("'col.names' must be a character vector of ",
                  q, " unique entries.", call. = FALSE)
        }
        if (col.names.plot == TRUE) {
            col.names.plot = col.names
        }
        else {
            col.names.plot = rep("", q)
        }
    }
    if (any(class.object %in% object.blocks)) {
        if (is.null(color.node)) {
            color.node = c("#FBB4AE", "#B3CDE3",
                "#CCEBC5", "#DECBE4", "#FED9A6",
                "#FFFFCC", "#E5D8BD", "#FDDAEC",
                "#F2F2F2")[1:length(blocks)]
            names(color.node) = blocks
        }
        else {
            if (!is.vector(color.node) || length(color.node) !=
                length(blocks))
                stop("'color.node' must be a vector of length ",
                  length(blocks), ".", call. = FALSE)
        }
    }
    else {
        if (is.null(color.node))
            color.node = c("white", "white")
        if (!is.list(color.node)) {
            if (!is.vector(color.node) || length(color.node) !=
                2)
                stop("'color.node' must be a vector of length 2.",
                  call. = FALSE)
        }
        else {
            stop("'color.node' must be a vector of length 2.",
                call. = FALSE)
        }
    }
    if (any(!sapply(color.node, function(x) {
        tryCatch(is.matrix(col2rgb(x)), error = function(e) FALSE)
    })))
        stop("'color.node' must be a character vector of recognized colors.",
            call. = FALSE)
    if (any(class.object %in% object.blocks)) {
        if (is.null(shape.node))
            shape.node = "circle"
        if (is.vector(shape.node)) {
            if (length(shape.node) == 1)
                shape.node = rep(shape.node, length(blocks))
        }
        if (!is.list(shape.node)) {
            if (!is.vector(shape.node) || length(shape.node) !=
                length(blocks))
                stop("'shape.node' must be a character vector of length ",
                  length(blocks), ".", call. = FALSE)
        }
        else {
            stop("'shape.node' must be a numeric vector of length ",
                length(blocks), ".", call. = FALSE)
        }
        if (!all(shape.node %in% c("none", "circle",
            "rectangle")))
            stop("elements of 'shape.node' must be from {'none', 'circle', 'rectangle'}.",
                call. = FALSE)
        if (is.null(names(shape.node)))
            names(shape.node) = blocks
    }
    else {
        if (is.null(shape.node))
            shape.node = c("circle", "rectangle")
        if (!is.list(shape.node)) {
            if (!is.vector(shape.node) || length(shape.node) !=
                2)
                stop("'shape.node' must be a vector of length 2.",
                  call. = FALSE)
        }
        else {
            stop("'shape.node' must be a vector of length 2.",
                call. = FALSE)
        }
        if (!all(shape.node %in% c("none", "circle",
            "rectangle")))
            stop("elements of 'shape.node' must be from {'none', 'circle', 'rectangle'}.",
                call. = FALSE)
    }
    if (!is.finite(cex.node.name) || cex.node.name < 0 || length(cex.node.name) >
        1)
        stop("'cex.node.name' must be a non-negative numerical value.",
            call. = FALSE)
    if (length(color.edge) < 2 && (!is(color.edge, "function")))
        stop("'color.edge' must be a vector of length larger than or equal to 2.",
            call. = FALSE)
    if ((length(color.edge)%%2) != 0 && (!is(color.edge, "function")) &&
        isTRUE(symkey))
        stop("'color.edge' must be a vector of length an even number if 'symkey = TRUE'.",
            call. = FALSE)
    if (any(!sapply(color.edge, function(x) {
        tryCatch(is.matrix(col2rgb(x)), error = function(e) FALSE)
    })))
        stop("'color.edge' must be a character vector of recognized colors.",
            call. = FALSE)
    if (length(lty.edge) > 2)
        stop("\"lty.edge\" must a character vector of up to 2 entries from\n        'solid', 'dashed', 'dotted', 'dotdash', 'longdash', twodash' or 'blank'.\n        see ?network",
            call. = FALSE)
    if (length(lty.edge) == 1)
        lty.edge = c(lty.edge, lty.edge)
    choices = c("solid", "dashed", "dotted",
        "dotdash", "longdash", "twodash", "blank")
    lty.edge = choices[pmatch(lty.edge, choices, duplicates.ok = TRUE)]
    if (any(is.na(lty.edge)))
        stop("'lty.edge' should be from 'solid', 'dashed', 'dotted', 'dotdash', 'longdash', twodash' or 'blank'.",
            call. = FALSE)
    if (length(lwd.edge) > 2)
        stop("'lwd.edge' must be a vector of up to 2 positive numbers.\n        See ?network")
    if (length(lwd.edge) == 1)
        lwd.edge = c(lwd.edge, lwd.edge)
    if (length(lwd.edge) != 2 || any(!is.finite(lwd.edge)) ||
        any(lwd.edge <= 0))
        stop("'lwd.edge' must be positive.")
    if (!is.logical(show.edge.labels))
        stop("'show.edge.labels' must be a logical constant (TRUE or FALSE).",
            call. = FALSE)
    if (!is.finite(cex.edge.label) || cex.edge.label < 0 || length(cex.edge.label) >
        1)
        stop("'cex.edge.label' must be a non-negative numerical value.",
            call. = FALSE)
    if (!is.logical(show.color.key))
        stop("'show.color.key' must be a logical constant (TRUE or FALSE).",
            call. = FALSE)
    if (!is.logical(symkey))
        stop("'symkey' must be a logical constant (TRUE or FALSE).",
            call. = FALSE)
    if (length(keysize) != 2 || any(!is.finite(keysize)))
        stop("'keysize' must be a numeric vector of length 2.",
            call. = FALSE)
    if (length(keysize.label) != 1 || any(!is.finite(keysize)))
        stop("'keysize' must be a numeric vector of length 1.",
            call. = FALSE)
    if (!is.logical(interactive))
        stop("'interactive' must be a logical constant (TRUE or FALSE).",
            call. = FALSE)
    if (!is.null(layout.fun) && !is(layout.fun, "function"))
        stop("'layout.fun' must be a valid layout function.",
            call. = FALSE)
    if (!(any(class.object %in% object.blocks)))
        w = as.vector(t(mat))
    if (round(max(abs(w)), 2) == 0)
        stop("There is no correlation between these blocks whith these components.",
            "Try a different value of 'comp'.", call. = FALSE)
    if (!is.numeric(cutoff) || cutoff < 0 || cutoff > 1)
        stop("'cutoff' should be a numeric between 0 and 1",
            call. = FALSE)
    if (cutoff > max(abs(w)))
        stop("You have chosen a high cutoff value of ",
            cutoff, " which is greaer than the max value in the similarity matrix which is ",
            round(max(abs(w)), 2), call. = FALSE)
    if (any(class.object %in% object.blocks)) {
        group = NULL
        temp = lapply(mat$X, function(x) colnames(x))
        for (i in 1:length(temp)) {
            group = c(group, rep(names(temp)[i], length(temp[[i]])))
        }
        nodes = data.frame(name = unlist(temp), group = group)
        ## print("--nodes")
        ## print(nodes)
        ## print(dim(nodes))
    }
    else if (any(class.object %in% object.pls)) {
        w = as.vector(t(mat))
        Xn = sum(keep.X)
        Yn = sum(keep.Y)
        node.X = row.names
        node.Y = col.names
        row.names.plot = row.names.plot[keep.X]
        col.names.plot = col.names.plot[keep.Y]
        nodes = data.frame(name = c(node.X, node.Y), group = c(rep("x",
            Xn), rep("y", Yn)))
        node.X = rep(node.X, each = Yn)
        node.Y = rep(node.Y, Xn)
    }
    else {
        node.X = row.names
        node.Y = col.names
        nodes = data.frame(name = c(node.X, node.Y), group = c(rep("x",
            p), rep("y", q)))
        node.X = rep(node.X, each = q)
        node.Y = rep(node.Y, p)
    }
    ##########################
    relations = data.frame(from = node.X, to = node.Y, weight = w)
    id = mixOmics:::bin.color(w, cutoff = cutoff, breaks = breaks, col = color.edge,
        symkey = symkey)
    col.id = id$bin
    color.edge = id$col[col.id]
    idx = (abs(w) >= cutoff)
    ## print(dim(relations))
    relations = relations[idx, ]
    ## print(head(relations))
    ## print(dim(relations))
    ## print("Arg" %in% relations[,1])
    ## print("Arg" %in% relations[,2])
    color.edge = color.edge[idx]
    ## print(head(nodes))
    ## print(dim(nodes))
    ## print(nodes$name)
    ## print(unique(c(relations$from,relations$to)))



    ## print(nodes$name[id.nodes])
    ## print(id.nodes)
    ## print(length(id.nodes))
#    nodes <- nodes[ id.nodes, ]
    ## print(nodes)
    ## print(dim(nodes))
    ## print(head(relations))
    ## print(dim(relations))

    gR = graph.data.frame(relations, directed = FALSE, vertices = nodes)
    ## AB
    ## Nodes to keep
    ## print(unique(c(relations$from,relations$to)))
    ## print(names(V(gR)))
    id.nodes <- names(V(gR)) %in% unique(c(relations$from,relations$to))
    ## print(names(V(gR)[id.nodes]))
    ## AB
    ## print(gR)
    ## print(gR)
    ## print(V(gR))
    V(gR)$label.color = "black"
    V(gR)$label.family = "sans"
    if (any(class.object %in% object.blocks)) {
        V(gR)$label = unlist(block.var.names)
        j = 1
        for (i in blocks) {
            V(gR)$color[V(gR)$group == i] = color.node[j]
            V(gR)$shape[V(gR)$group == i] = shape.node[j]
            j = j + 1
        }
    }
    else {
        V(gR)$label = c(row.names.plot, col.names.plot)
        V(gR)$color = color.node[1]
        V(gR)$color[V(gR)$group == "y"] = color.node[2]
        V(gR)$shape = shape.node[1]
        V(gR)$shape[V(gR)$group == "y"] = shape.node[2]
    }
    if (show.edge.labels)
        E(gR)$label = round(E(gR)$weight, 2)
    E(gR)$label.color = "black"
    E(gR)$color = color.edge
    E(gR)$lty = lty.edge[1]
    E(gR)$lty[E(gR)$weight < 0] = lty.edge[2]
    E(gR)$width = lwd.edge[1]
    E(gR)$width[E(gR)$weight < 0] = lwd.edge[2]
    gR = delete.vertices(gR, which(degree(gR) == 0))
    lwid = c(keysize[1], 4)
    lhei = c(keysize[2], 4)
    lmat = matrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE)
    nc = length(id$col)
    x = seq(0, 1, length = nc + 2)
    z.mat = seq(0, 1, length = nc + 1)
    z.mat = matrix(z.mat, ncol = 1)
    if ((id$lim[1] < -cutoff) & (id$lim[2] < cutoff)) {
        xv = c(0, x[nc + 1])
        lv = round(c(id$lim[1], -cutoff), 2)
        col = c(id$col, "white")
    }
    if ((id$lim[1] > -cutoff) & (id$lim[2] > cutoff)) {
        xv = c(x[2], 1)
        lv = round(c(cutoff, id$lim[2]), 2)
        col = c("white", id$col)
    }
    if ((id$lim[1] < -cutoff) & (id$lim[2] > cutoff)) {
        idn = max(which(id$breaks < 0))
        idp = min(which(id$breaks > 0))
        xv = c(0, x[idn + 1], x[idp], 1)
        lv = round(c(id$lim[1], -cutoff, cutoff, id$lim[2]),
            2)
        col = c(id$col[1:idn], "white", id$col[(idn + 1):nc])
    }
    nn = vcount(gR)
    V(gR)$label.cex = min(2.5 * cex.node.name/log(nn), 1)
    E(gR)$label.cex = min(2.25 * cex.edge.label/log(nn), 1)
    cex0 = 2 * V(gR)$label.cex
    def.par = par(no.readonly = TRUE)
    dev.new()
    par(pty = "s", mar = c(0, 0, 0, 0), mfrow = c(1, 1))
    plot(1:100, 1:100, type = "n", axes = FALSE, xlab = "",
        ylab = "")
    cha = V(gR)$label
    cha = paste("", cha, "")
    xh = strwidth(cha, cex = cex0) * 1.5
    yh = strheight(cha, cex = cex0) * 3
    V(gR)$size = xh
    V(gR)$size2 = yh
    dev.off()
    ## AB
    ## print(names(V(gR)))
     present <- unique(unlist(strsplit(attr(E(gR),"vnames"),"\\|")))
     ## print(present)
    id.nodes <- names(V(gR)) %in% present
    ## print( !id.nodes)

    ## print(names(V(gR))[!id.nodes])
    ## print(names(V(gR))[id.nodes])


    if(any(!id.nodes)) gR <- delete_vertices(gR, names(V(gR))[!id.nodes])
    ## AB
    if (is.null(layout.fun)) {
        l = layout.fruchterman.reingold(gR, weights = (1 - abs(E(gR)$weight)))
    }
    else {
        l = layout.fun(gR)
        l <- l[names(V(gR)),]
    }
    if (isTRUE(!interactive)) {
        if (isTRUE(show.color.key)) {
            layout(lmat, widths = lwid, heights = lhei, respect = FALSE)
            par(mar = c(5, 4, 2, 1), cex = 0.75)
            image(z.mat, col = col, xaxt = "n", yaxt = "n")
            box()
            par(usr = c(0, 1, 0, 1))
            axis(1, at = xv, labels = lv, cex.axis = keysize.label)
            title("Color key", font.main = 1, cex.main = keysize.label)
            par(def.par)
            par(new = TRUE)
        }
        par(pty = "s", mar = c(0, 0, 0, 0), mfrow = c(1,
            1))
        plot(gR, layout = l)
        par(def.par)
    }
    gE.none = FALSE
    if (isTRUE(interactive)) {
        min.cut = cutoff
        max.cut = max(abs(w))
        cutoff.old = cutoff
        dev.new(width = 5, height = 2.7, xpos = -1)
        def.par = par(no.readonly = TRUE)
        cuts = seq(0, 1, length = 21)
        par(mai = c(0.25, 0.15, 0.3, 0.15), bg = gray(0.95))
        layout(matrix(c(0, 1, 0), ncol = 1, nrow = 3), widths = 1,
            heights = c(0.25, 1, 0.25))
        plot(cuts, type = "n", rep(0, 21), xlab = "",
            ylab = "", xlim = c(-0.1, 1.1), axes = FALSE)
        title("cutoff control", cex.main = 1.9, font.main = 1)
        text(0.5, -0.6, "value", cex = 1.5)
        text(0, -0.6, round(min.cut, 2), cex = 1.4)
        text(1, -0.6, round(max.cut, 2), cex = 1.4)
        mtext(min.cut, side = 1, line = -1, outer = FALSE, cex = 0.95)
        rect(-0.1, -0.3, -0.02, 0.3, col = "white")
        rect(1.02, -0.3, 1.1, 0.3, col = "white")
        points(1.06, 0, pch = 3, cex = 2.4)
        lines(c(-0.085, -0.035), c(0, 0))
        for (i in seq(0, 1, length = 21)) lines(c(i, i), c(-0.22,
            0.2))
        x = pos = 0
        rect(-0.01, -0.045, x, 0.04, col = "red")
        rect(x, -0.045, 1.01, 0.04, col = "white")
        bar.dev = dev.cur()
        dev.new()
        net.dev = dev.cur()
        if (isTRUE(show.color.key)) {
            layout(lmat, widths = lwid, heights = lhei, respect = FALSE)
            par(mar = c(5, 4, 2, 1), cex = 0.75)
            image(z.mat, col = col, xaxt = "n", yaxt = "n")
            box()
            par(usr = c(0, 1, 0, 1))
            axis(1, at = xv, labels = lv, cex.axis = keysize.label)
            title("Color key", font.main = 1, cex.main = keysize.label)
            par(def.par)
            par(new = TRUE)
        }
        par(pty = "s", mar = c(0, 0, 0, 0))
        plot(gR, layout = l)
        par(def.par)
        old.pos = -1
        repeat {
            dev.set(bar.dev)
            z = locator(1, type = "n")
            x = z[[1]]
            y = z[[2]]
            if (is.null(z))
                break
            if (0 <= x & x <= 1 & -0.22 <= y & y <= 0.22) {
                rect(0, -0.045, x, 0.04, col = "red")
                rect(x, -0.045, 1.01, 0.04, col = "white")
                pos = x
            }
            if (1.02 <= x & x <= 1.1 & -0.3 <= y & y <= 0.3) {
                x = pos + 0.05
                idx = which.min(abs(cuts - x))
                x = cuts[idx]
                pos = x
                rect(0, -0.045, x, 0.04, col = "red")
                rect(x, -0.045, 1.01, 0.04, col = "white")
            }
            if (-0.1 <= x & x <= -0.02 & -0.3 <= y & y <= 0.3) {
                x = pos - 0.05
                idx = which.min(abs(cuts - x))
                x = cuts[idx]
                pos = x
                rect(0, -0.045, x, 0.04, col = "red")
                rect(x, -0.045, 1.01, 0.04, col = "white")
            }
            if (old.pos != pos) {
                old.pos = pos
                rect(0.4, -0.8, 0.6, -1.5, col = gray(0.95),
                  border = NA)
                cutoff = (max.cut - min.cut) * pos + min.cut
                mtext(round(cutoff, 3), side = 1, line = -1,
                  cex = 0.9)
                dev.set(net.dev)
                if (cutoff >= cutoff.old) {
                  supp.edge = E(gR)[abs(E(gR)$weight) < cutoff]
                  gE = delete.edges(gR, supp.edge)
                  gE = delete.vertices(gE, which(degree(gE) ==
                    0))
                  nn = vcount(gE)
                  V(gR)$label.cex = min(2.5 * cex.node.name/log(nn),
                    1)
                  E(gR)$label.cex = min(2.25 * cex.edge.label/log(nn),
                    1)
                  cex0 = 2 * V(gE)$label.cex
                  def.par = par(no.readonly = TRUE)
                  par(pty = "s", mar = c(0, 0, 0, 0))
                  plot(1:100, 1:100, type = "n", xaxt = "n")
                  cha = V(gE)$label
                  cha = paste("", cha, "")
                  xh = strwidth(cha, cex = cex0) * 1.5
                  yh = strheight(cha, cex = cex0) * 3
                  V(gE)$size = xh
                  V(gE)$size2 = yh
                  par(def.par)
                  if (is.null(layout.fun)) {
                    l = layout.fruchterman.reingold(gE, weights = (1 -
                      abs(E(gE)$weight)))
                  }
                  else {
                    l = layout.fun(gE)
                  }
                  if (isTRUE(show.color.key)) {
                    layout(lmat, widths = lwid, heights = lhei,
                      respect = FALSE)
                    par(mar = c(5, 4, 2, 1), cex = 0.75)
                    image(z.mat, col = col, xaxt = "n",
                      yaxt = "n")
                    box()
                    par(usr = c(0, 1, 0, 1))
                    axis(1, at = xv, labels = lv, cex.axis = keysize.label)
                    title("Color key", font.main = 1, cex.main = keysize.label)
                    par(def.par)
                    par(new = TRUE)
                  }
                  par(pty = "s", mar = c(0, 0, 0, 0))
                  plot(gE, layout = l)
                  par(def.par)
                  cutoff.old = cutoff
                }
                else {
                  supp.edge = E(gR)[abs(E(gR)$weight) < cutoff]
                  gE = delete.edges(gR, supp.edge)
                  gE = delete.vertices(gE, which(degree(gE) ==
                    0))
                  nn = vcount(gE)
                  V(gR)$label.cex = min(2.5 * cex.node.name/log(nn),
                    1)
                  E(gR)$label.cex = min(2.25 * cex.edge.label/log(nn),
                    1)
                  cex0 = 2 * V(gE)$label.cex
                  def.par = par(no.readonly = TRUE)
                  par(pty = "s", mar = c(0, 0, 0, 0))
                  plot(1:100, 1:100, type = "n", xaxt = "n")
                  cha = V(gE)$label
                  cha = paste("", cha, "")
                  xh = strwidth(cha, cex = cex0) * 1.5
                  yh = strheight(cha, cex = cex0) * 3
                  V(gE)$size = xh
                  V(gE)$size2 = yh
                  par(def.par)
                  if (is.null(layout.fun)) {
                    l = layout.fruchterman.reingold(gE, weights = (1 -
                      abs(E(gE)$weight)))
                  }
                  else {
                    l = layout.fun(gE)
                  }
                  if (isTRUE(show.color.key)) {
                    layout(lmat, widths = lwid, heights = lhei,
                      respect = FALSE)
                    par(mar = c(5, 4, 2, 1), cex = 0.75)
                    image(z.mat, col = col, xaxt = "n",
                      yaxt = "n")
                    box()
                    par(usr = c(0, 1, 0, 1))
                    axis(1, at = xv, labels = lv, cex.axis = keysize.label)
                    title("Color key", font.main = 1, cex.main = keysize.label)
                    par(def.par)
                    par(new = TRUE)
                  }
                  par(pty = "s", mar = c(0, 0, 0, 0))
                  plot(gE, layout = l)
                  par(def.par)
                  cutoff.old = cutoff
                }
                gE.none = TRUE
            }
        }
        if (gE.none != FALSE)
            gR = gE
    }
    ## AB
    ## print(dim(l))
    ly <- l
    rownames(ly) <- names(V(gR))
    ## AB
    res = list(gR = gR)
    if (any(class.object %in% object.blocks)) {
        l = 1
        for (i in 1:(length(blocks) - 1)) {
            for (j in (i + 1):length(blocks)) {
                M_block[[l]][abs(M_block[[l]]) < cutoff] = 0
                res[paste("M", blocks[i], blocks[j], sep = "_")] = list(M_block[[l]])
                l = l + 1
            }
        }
    }
    else {
        mat[abs(mat) < cutoff] = 0
        res$M = mat
    }
    res$cutoff = cutoff
    res$layout <- ly
    if (!is.null(save))
        dev.off()
    return(invisible(res))
}

```



```{r }

``` 
