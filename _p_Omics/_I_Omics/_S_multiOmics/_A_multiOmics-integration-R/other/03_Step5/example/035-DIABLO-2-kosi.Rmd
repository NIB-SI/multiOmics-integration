
The selected variables can be extracted with the function selectVar(), for 
example in each block, as seen below. Note that the stability of selected 
variables can be extracted from the output of the perf() function. 


```{r } # the features selected from components for (comp in 1:ncomp){ 
cat("\nComponent ", comp,":\n") for(i in 1:length(data)){ 
cat(names(data)[i],"\n") print(selectVar(final.diablo.model, comp = 
comp)[[i]]$name) } } ``` 

## Sample plots 

plotDIABLO() is a diagnostic plot to check whether the correlation between 
components from each data set has been maximised as specified in the design 
matrix. We specify which dimension to be assessed with the ncomp argument. 


```{r fig.height=7} for(comp in 1:ncomp){ plotDiablo(final.diablo.model, 
ncomp = comp) title(paste("Component",comp), adj=0.1, line=-1, outer=TRUE) } 
``` 

The sample plot with the plotIndiv() function projects each sample into the 
space spanned by the components of each block. Clustering of the samples can 
be  assessed with this plot. 

```{r fig.height=7} plind <- plotIndiv(final.diablo.model, 
          ind.names = FALSE, legend = TRUE, title = 'DIABLO Sample Plots', 
          guide="none", ellipse = TRUE ) 
``` 


In the arrow plot below, the start of the arrow indicates the centroid 
between all data sets for a given sample and the tips of the arrows indicate 
the location of that sample in each block. Such graphics highlight the 
agreement between all data sets at the sample level. While somewhat difficult 
to interpret, even qualitatively, this arrow plot shows proximities of C01 
and H01 (both day 1), C07 and C08, and H07 and H08 ( both a day apart). While 
C samples are in forth quadrant ( D1 < 0, D2 > 0), H samples have ( D1 < 0, 
D2 < 0) except H14 that is separated on the positive part of Dimension 1. 


```{r fig.height=7} plotArrow(final.diablo.model, ind.names = FALSE, legend = 
TRUE, 
          title = paste(groups,collapse=", ") 

          ) 
          ``` 


## Variable plots

Several graphical outputs are available to visualise and mine the 
associations between the selected variables. 

The best starting point to evaluate the correlation structure between 
variables is with the correlation circle plot. A majority of the qPCR 
variables are positively correlated only with the first component. The 
hormonomics and metabolomics variables seem to separate along first two 
dimensions. These first two components correlate highly with the selected 
variables from the all three dataset. From this, the correlation of each 
selected feature from all three datasets can be evaluated based on their 
proximity. 


```{r fig.width=8, fig.height=8} #if(length(data)==3) pick <- 1:3 else pick 
<- c(4,1:3) #cols <- c('orange1', 'brown1', 'lightgreen',"lightblue")[pick] 
#pchs <- c(16, 17, 15, 18)[pick] cols <- c('orange1', 'brown1', 'lightgreen') 
pchs <- c(16, 17, 15) plotVar(final.diablo.model, var.names = FALSE, 
        style = 'graphics', legend = TRUE , pch = pchs, cex = 
        rep(2,length(data)) , col = cols 
) 


``` 

The circos plot is exclusive to integrative frameworks and represents the 
correlations between variables of different types, represented on the side 
quadrants. It seems that the qPCR variables are almost entirely negatively 
correlated with the other two dataframes. Just few from metabolomics and 
hormonomics are positively correlated.  Note that these correlations are 
above a value of 0.7 (cutoff = 0.7). All  interpretations made above are only 
relevant for features with very strong correlations. 

Plot variables 

```{r fig.width=8,fig.height=7} #plotVar(res, cutoff=0.5, legend = TRUE, 
overlap=!FALSE, style='graphics') #plotVar(res, cutoff=0.5, legend = TRUE, 
overlap=FALSE, style='graphics') plotVar(final.diablo.model, cutoff=0.5, 
legend = TRUE, comp=c(1,2), overlap=FALSE, style='ggplot2', col=cols) 
plotVar(final.diablo.model, cutoff=0.5, legend = TRUE, comp=c(2,3), 
overlap=FALSE, col=cols) ``` 

```{r fig.width=7, fig.height=8} circosPlot(final.diablo.model, cutoff = 0.7, 
line = TRUE, 
           color.blocks= cols, color.cor = c(3,2), size.labels = 1 , 
           xpd=TRUE) 
``` 

## Relevance networks 

Another visualisation of the correlations between the different types of 
variables is the relevance network, which is also built on the similarity 
matrix (as is the circos plot). Colour represent variable type. 



```{r 035a, results='asis'} blocks <- combn(length(data),2) j <- 1 cutoff <- 
0.8 out35a <- "" for(j in 1:ncol(blocks)){ 
    out35a <- paste( out35a, knit_child("035a-DIABLO-network.Rmd", 
    quiet=!TRUE)) 

        if(interactive()) readline() } cat(out35a) ``` 


## Multipartite network 


```{r results='asis'} cutoff <- 0.0 x <- final.diablo.model layout.fun <- 
NULL label <- paste(.treat, collapse=", ") out35b <- "" 
  out35b <- paste( out35b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) cat(out35b) ``` 


```{r } # Save network layout in ly, used by my.layout function. 
if(exists(deparse(substitute(nw)))) ly <- nw$layout else ly <- NULL 

``` 



```{r results='asis'} cutoff <- 0.8 x <- final.diablo.model label <- 
paste(.treat, collapse=", ") out35b <- "" 
  out35b <- paste( out35b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) cat(out35b) ``` 

## Visualize loadings 

The function plotLoadings() visualises the loading weights of each selected 
variable on each component and each data set. The colour indicates the class 
in which the variable has the maximum level of expression (contrib = 'max') 
using the median (method = 'median'). Figure below depicts the loading values 
for each dimension. 


```{r plotLoadings, fig.height=7} for(i in 1:ncomp) 
plotLoadings(final.diablo.model, comp = i, contrib = 'max', method = 
'median') 

``` 


## Heatmap (clustered image map) 

The cimDIABLO() function is a clustered image map specifically implemented to 
represent the multi-omics molecular signature expression for each sample. 
From figure below the areas of homogeneous expression levels for a set of 
samples across a set of features can be determined. For instance, the H14 
samples were the only group to show extremely high levels of expression for a 
specific set of genes and metabolites. This indicates these features are 
fairly discriminating for this subtype. 


```{r cim1} cimfn <- "cim.png" png(cimfn, res = 600, width = 4000, height = 
4000) cimDiablo(final.diablo.model, size.legend=0.7) dev.off() 

``` 

![`r cimfn`](`r cimfn`) 

## AUC and ROC plots 

An AUC plot per block can also be obtained using the function auroc(). The 
interpretation of this output may not be particularly insightful in relation 
to the performance evaluation of our methods, but can complement the 
statistical analysis. 


```{r } par(mfrow=c(2,2)) for(i in 1:length(data)) auc.splsda = 
auroc(final.diablo.model, roc.block = names(data[i]), 
                   roc.comp = 1, print = FALSE) ``` 




```{r } res12 <- final.diablo.model 

``` 

## Final analysis 

Design matrix determines which datasets (blocks) are connected. We will 
connect all blocks. 

According to recommendation from tuning, design matrix should have small 
entries that provide better predictions. 

```{r } entry <- .entry design <- matrix(entry, length(data), length(data), 
   dimnames = list(names(data), names(data))) diag(design) <- 0 design ``` 

Based on tuning part, we can keep two to four components. 

```{r } list.keepX ncomp = length(list.keepX[[1]]) ncomp ``` You can also 
control the number of variables to be kept for each component. ```{r } #keepX 
<- list(XX=rep(3,ncomp), YY=rep(3,ncomp), ZZ=rep(3, ncomp)) #keepX ``` We 
will not restrict variables. 

Now we can do the calculation ```{r } res <- block.splsda(X = data 
    , Y = as.factor(state) , ncomp = ncomp , keepX = list.keepX , design = 
    design ) 

``` 

Model `res` and `final.diablo.model` do not differ: 

```{r } sapply(names(res$loadings), function(name) all(res$loadings[[name]] - 
final.diablo.model$loadings[[name]]==0)) ``` 

Estimate classification error rate. The error rate should drop by more 
components used. 

```{r eval=FALSE} # run component number tuning with repeated CV 
system.time(perf.diablo  <-  perf(res, validation = 'Mfold', 
                   folds = 3, nrepeat = 10)) 

plot(perf.diablo) # plot output of tuning 

``` 



Names of kept variables 

```{r } # the features selected to form components for (comp in 1:ncomp){ 
cat("\nComponent ", comp,":\n") for(i in 1:length(data)){ 
cat(names(data)[i],"\n") print(selectVar(res, comp = comp)[[i]]$name) } } ``` 

One would like to reduce the number of nodes, especially for proteomics data. 
One option is to reduce datasets in a way to keep only the variables in the 
selectVars in original data in . We will keep variables from the first two 
components. ```{r } keptVars <- unique(c( 
 selectVar(res, comp=1)[[1]]$name ,selectVar(res, comp=2)[[1]]$name ) ) 
which(keptVars%in%selectVar(res, comp=1)[[1]]$name) 
which(keptVars%in%selectVar(res, comp=2)[[1]]$name) ``` 


### Visualise variables Loadings ```{r fig.height=7} sapply(res$loadings, 
head, 30) #plotLoadings(res, comp = 1, method = 'median') #plotLoadings(res, 
comp = 1, method = 'median', contrib="max") for( i in 1:ncomp) 
plotLoadings(res, comp = i, method = 'median', contrib="max") 

``` 


Plot variables 

```{r fig.width=8,fig.height=7} #plotVar(res, cutoff=0.5, legend = TRUE, 
overlap=!FALSE, style='graphics') #plotVar(res, cutoff=0.5, legend = TRUE, 
overlap=FALSE, style='graphics') plotVar(res, cutoff=0.5, legend = TRUE, 
comp=c(1,2), overlap=FALSE, style='ggplot2', col=cols) plotVar(res, 
cutoff=0.5, legend = TRUE, comp=c(2,3), overlap=FALSE, col=cols) ``` 


## Differential networks Here we will show differential networks between 
treatments. ```{r eval=FALSE, results='asis'} cutoffs <- c(0.7) pairs <- 
combn(1:length(names(res$X)),2) outn <- "" j <- 4 cutoff <- 0.5 for(j in 
1:ncol(pairs) ){ 
    pair <- pairs[,j] X <- data[[pair[1]]] Y <- data[[pair[2]]] datasets <- 
    names(data)[pair] outn <- paste( outn, 
    knit_child("023-prepare-networkdiff.Rmd", quiet=TRUE)) 
   for(cutoff in cutoffs){ outn <- paste( outn, knit_child("035-Network.Rmd", 
   quiet=TRUE)) } 
} cat(outn) ``` 



```{r fig.width=8, fig.height=8} size.variables <- 1 sim 
<-circosPlot(final.diablo.model, cutoff = 0.5, line = TRUE, 
           color.blocks= cols, color.cor = c(3,2), size.labels = 1 , 
           size.variables = size.variables , xpd=TRUE) 
circosPlot(final.diablo.model, cutoff = 0.78, line = TRUE, color.blocks= 
           cols, color.cor = c(3,2), size.labels = 1 , size.variables = 
           size.variables , xpd=TRUE) 
circosPlot(final.diablo.model, cutoff = 0.9, line = TRUE, color.blocks= cols, 
           color.cor = c(3,2), size.labels = 1 , size.variables = 
           size.variables , xpd=TRUE) 
circosPlot(final.diablo.model, cutoff = 0.95, line = TRUE, color.blocks= 
           cols, color.cor = c(3,2), size.labels = 1 , size.variables = 
           size.variables , xpd=TRUE) 

``` 


```{r, eval=FALSE, echo=FALSE} pdf("circosPlot.pdf") size.variables <- 1 
circosPlot(final.diablo.model, cutoff = 0.9, line = TRUE, 
           color.blocks= cols, color.cor = c(3,2), size.labels = 1 , 
           size.variables = size.variables , xpd=TRUE) 
dev.off() ``` 






# Export networks to file 



Partial models for each treatment 



## Network for `r .treat[1]`. 

```{r } filter <- pdata$Treatment %in% .treat[1] XX1 <- lapply(CCDATA, 
function(x) if(is.null(dim(x))) x[filter] else x[filter,]) table(XX1$status) 
``` 

```{r } res1 <- block.splsda(X = XX1[-1] 
    , Y = as.factor(XX1[[1]]) , ncomp = ncomp , keepX = list.keepX , design = 
    design ) 

``` 

```{r results='asis'} cutoff <- 0.0 x <- res1 layout.fun <- NULL label 
<-.treat[1] out23b <- "" 
  out23b <- paste( out23b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) N1 <- nw cat(out23b) ``` 

Save network layout for further plots, used by layout function `my.layout`. 
```{r } ly <- nw$layout ``` 

```{r results='asis'} cutoff <- 0.7 x <- res1 layout.fun <- my.layout label 
<- .treat[1] out23b <- "" 
  out23b <- paste( out23b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) cat(out23b) ``` 

## Network for `r .treat[2]`. 

```{r } filter <- pdata$Treatment %in% .treat[2] XX2 <- lapply(CCDATA, 
function(x) if(is.null(dim(x))) x[filter] else x[filter,]) table(XX2$status) 
``` 

```{r } res2 <- block.splsda(X = XX2[-1] 
    , Y = as.factor(XX2[[1]]) , ncomp = ncomp , keepX = list.keepX , design = 
    design ) 

``` 



```{r results='asis'} cutoff <- 0.0 x <- res2 layout.fun <- NULL label <- 
.treat[2] out23b <- "" 
  out23b <- paste( out23b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) N2 <- nw cat(out23b) ``` 

Save layout for further plots, used by layout function `my.layout`. ```{r } 
ly <- nw$layout ``` 


```{r results='asis'} cutoff <- 0.7 x <- res2 layout.fun <- my.layout label 
<- .treat[2] out23b <- "" 
  out23b <- paste( out23b, knit_child("035b-multipartite-network.Rmd", 
quiet=TRUE)) cat(out23b) ``` 




Save network file for combined and single treatments. Networks are in objects 
`res`, `res1` and `res2`. 



```{r} write("Mid diablo 5 41 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "bla.log", 
append=TRUE) ``` ## Network for `r paste(.treat, collapse=" and ")`. 

```{r} # Complete network, cutoff = 0, both datasets <- names(CCDATA[-1]) 
ndatasets<- length(datasets) # N12 <- network(res 
    , cutoff = 0 , blocks = 1:ndatasets , shape.node = c("rectangle") , save 
    = "png" , name.save="network-CH" ) 
# e <- extractEdges2(N12) colnames(e)[ncol(e)] <- paste(.treat, collapse=".") 
head(e) tail(e) dim(e) ``` 

```{r} # treatment 1 e1 <- extractEdges2(N1) colnames(e1)[ncol(e1)] <- 
.treat[1] head(e1) dim(e1) 

``` 

```{r } e <- merge(e,e1, sort=FALSE, all=TRUE) head(e) tail(e) ``` 

```{r } # treatment 2 .treat[2] e2 <- extractEdges2(N2) 
colnames(e2)[ncol(e2)] <- .treat[2] head(e2) dim(e2) 

``` 

```{r } e <- merge(e,e2, sort=FALSE, all=TRUE) head(e) tail(e) # ``` ```{r} 
write("Mid diablo 5 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "bla.log", append=TRUE) 
``` 


Compose file name and necessary information for network export file 

```{r} file <- paste0("network-",paste(.treat, 
collapse="_"),"-",paste(datasets, collapse="_"),".txt") label0 <- 
paste(paste(.treat, collapse=", "),"|",paste(datasets, collapse=", "),"; 
cutoff =",0) title <- label0 sets <- 1:length(DATA) suffix <- 
paste0(substr(names(DATA),1,2)[sets[-1]],collapse="-") 

``` 


```{r} write("Mid diablo 6 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", "bla.log", 
append=TRUE) write(file.path(suffix,file), "bla.log", append=TRUE) 
write(file, "bla.log", append=TRUE) 

``` 

```{r} length(str(e)) ``` 


Export edges table 

```{r  } #e <- data.frame(x=1:10,y=1:10) #my.write.table(e, 
file="network.txt",meta=FALSE) write.table(e, file = file, na="0") ``` 

Table with edges for networks based on combined treatments (C, H) and single 
treatments (C) and (H) is exported as a text file. This table can be used for 
inspection and filtering out edges based on selected cutoff. Missing edges 
are labeled as weight 0. This enables numeric filtration in Excel. 
